[[enforcing-anti-affinity-rules]]
== Практический пример: обеспечение соблюдения правил анти-аффинности

Мы можем использовать методы, которые мы узнали до сих пор, чтобы написать сценарий автоматизации, чтобы решить реалистичную задачу.

=== Task

Напишите метод автоматизации, который обеспечивает соблюдение правил антиаффинности для виртуальных машин, на основе тега _server_role_, применяемой к каждой виртуальной машине. Должен быть только одна виртуальная машина любого типа _server_role_, работающего на любом хосте в кластере.

Метод автоматизации должен выполняться с кнопки, видимой на странице деталей виртуальной машины. Если другой виртуальная машина с тем же тегом _Server_Role_ находится на одном и том же хосте (гипервизор), что и отображаемая виртуальная машина, то мы живем мигрируем текущую виртуальную машину на другой хост без каких -либо других подобных виртуальных машин. Мы также отправляем электронное письмо всем пользователям в группе EVMGROUP-администратора, что произошла миграция.

=== Solution

Мы можем выполнить эту задачу следующим образом (весь скрипт-это ссылка: https: //github.com/pemcg/mastering-automation-in-cloudforms-4.2-and-manageiq-euwe/tree/master/enforcing_anti_affinity_rules/scripts [здесь]). Мы определим два метода внутри нашего сценария Ruby, `relocate_vm` и` send_email`. Наш основной код будет простой петлей итерации.

==== relocate_vm

Первый метод `relocate_vm` использует виртуальный столбец (` vm.host_name`) и несколько ассоциаций, чтобы найти подходящий хост (гипервизор) для переноса виртуальной машины. Эти ассоциации представляют собой `vm.ems_cluster`, чтобы найти кластер, на котором работает наша виртуальная машина,` ems_cluster.hosts`, чтобы найти другие гипервизоры в кластере и `host.vms`, чтобы получить список виртуальных машин на гипервизоре. Наконец, он вызывает метод (`vm.migrate`) для выполнения миграции виртуальной машины.

[source,ruby]
----
def relocate_vm (VM)
  #
# Получите имя нашего хоста
  #
Our_host = vm.host_name # <- виртуальный столбец
  #
# Проверка через другие хосты в нашем кластере
  #
target_host = nil
vm.ems_cluster.hosts.each do | this_host |      # <- два уровня ассоциации
Далее, если this_host.name == our_host
host_invalid = false
this_host.vms.each do | this_vm |             # <- Ассоциация
Если this_vm.tags (: server_role). first == our_server_role
host_invalid = true
перерыв
конец
конец
Далее, если host_invalid
    #
# Если мы доберемся сюда, то виртуальные машины Duplicate Server_Role не найдены
# на этом хосте
    #
target_host = this_host
перерыв
конец
Если target_host.nil?
Поднимите "не подходящий хост для переноса vm #{vm.name} на"
еще
$ evm.log (: info "Migrating VM #{vm.name} на хост: #{target_host.name}")
    #
# Мигрировать виртуальную машину на этот хост
    #
vm.migrate (target_host) # <- Метод
конец
return target_host.name
конец
----

==== send_email

Второй метод, `send_email`, отправляет электронное письмо всем участникам группы пользователей. Он использует ассоциацию `group.users`, чтобы найти всех пользователей в конкретной группе, атрибут` user.email`, чтобы найти адрес электронной почты пользователя, и вызывает `$ evm.execute` для запуска внутреннего метода`: send_email`.

[source,ruby]
----
def send_email (group_name, vm_name, new_host)
  #
# Найдите группу переданную нам, и вытащите электронные письма пользователей
  #
получатели = []
Group = $ evm.vmdb ('miq_group'). find_by_description (group_name)
group.users.ed do | Group_member |             # <- Ассоциация
получатели << Group_member.email # <- атрибут
конец
  #
# 'from'-это текущий пользователь, который нажал кнопку, нажав кнопку
  #
от = $ evm.root ['user']. Электронная почта
Субъект = "Миграция виртуальной машины"
Body = "vm name: #{vm_name} был мигрирован в прямом эфире на хост: #{new_host}"
тело += "в соответствии с правилами анти-аффинности"
  #
# Отправить электронные письма
  #
получатели
$ evm.log (: info, "Отправка электронной почты в <#{получатель}> из <#{от}> \
Тема: <#{субъект}> ")
$ evm.execute (: send_email, получатель, от, субъект, тело)
конец
конец
----

==== Main Code

Мы завершим наш основной раздел кода в блок `begin` ->` Rescue`, чтобы мы могли поймать и обрабатывать любые исключения.

[source,ruby]
----
начинать
  #----------------------------------------------------------------------------
# Главный код
  #----------------------------------------------------------------------------
  #
# Нас вызвали из кнопки на объекте виртуальной машины, поэтому мы знаем, что
# $ evm.root ['vm'] будет загружен
  #
vm = $ evm.root ['vm']
  #
# Узнайте эту виртуальную машину Server_role
  #
out_server_role = vm.tags (: server_role). First
Если не наши_SERVER_ROLE.BLANK?
$ evm.log (: info, "vm #{vm.name} имеет тег Server_role: #{our_server_role}")
    #
# Проверка через другие виртуальные машины на одном хосте
    #
vm.host.vms.each do | this_vm |             # <- два уровня ассоциации
Далее, если это так_vm.name == vm.name
Если this_vm.tags (: server_role). first == our_server_role
$ evm.log (: info, "vm #{this_vm.name} также имеет тег Server_role: \
#{our_server_role}, предпринимаемое действие ")")
new_host = relocate_vm (vm)
send_email ('evmgroup-administrator', vm.name, new_host)
конец
конец
конец
Выход miq_ok

rescue => err
$ evm.log (: error, "[#{err}] \ n#{err.backtrace.join (" \ n ")}")
Выход miq_stop
конец
----

Основной код определяет объект модели службы виртуальной машины от `$ evm.root ['vm']` и извлекает первый тег 'Server_role', применяемый к виртуальной машине (см. Ссылку: ../ VM_Provision_state_machine/grail.asciidoc [машина состояния виртуальной машины] для более подробной информации об использовании тегов из автоматизации). Затем он вместе цепей двух ассоциаций (`vm.host` и` host.vms`), чтобы определить другие виртуальные машины, работающие на одном и том же гипервизоре, что и наша виртуальная машина. Если какая-либо из этих виртуальных машин имеет тот же тег «Server_role», что и наш виртуальная машина, мы называем метод `relocate_vm` и отправляем электронное письмо группе« evmgroup-administrator », что виртуальная машина была перемещена.

=== Summary

Здесь мы показали, как мы можем выполнить реалистичную задачу с относительно простым сценарием Ruby, используя многие концепции, которые мы узнали до сих пор в книге. Мы работали с объектами модели службы, представляющих пользователя, группы, виртуальной машины, кластера и гипервизора, и мы переселили ассоциации между некоторыми из них. Мы прочитали из атрибута объекта и виртуального столбца и назвали метод объекта для выполнения операции мигрирования. Наконец, мы исследовали работу с тегами, и мы использовали `$ evm.execute`, чтобы отправить электронное письмо.

Хотя большинство современных платформ виртуализации обладают встроенными анти-аффинными возможностями, это все еще является полезным примером того, как мы можем достичь выбранного размещения рабочей нагрузки на основе тегов. Когда мы реализуем такого рода размещение на основе тегов, мы должны убедиться, что наши рабочие нагрузки виртуальной машины не помечаются несколько раз с возможными противоречивыми результатами, например, один тег, подразумевающий сродство и еще одну анти-аффиду.

==== Further Reading

http://cloudformsblog.redhat.com/2013/05/13/workload-pleation-by-type-not-near-that/цин загрузку типом (не ближе к этому)]]
