[[miscellaneous-tips]]
== Разное советы

Мы достигли последней главы в книге, и наше путешествие к мастерству автоматизации почти завершено. В этой последней главе мы рассмотрим некоторые разные советы, которые могут помочь нам, когда мы работаем с автоматизацией.

=== Updating the Appliance

Когда незначительное обновление для CloudForms выпускается и устанавливается, любые изменения в коде автоматизации автоматически не видны для Automate Explorer.

Перейдите в ** Import /Export **, и*сбросить все пользовательские классы и экземпляры Datastore, чтобы по умолчанию*, чтобы добавить и видимые обновления (см. << i1 >>).

[[i1]]
. Резюме заблокированных доменов после обновления устройства
image::images/ss1.png[ch47_ss,500,align="center"]
{zwsp} +

[NOTE]
Это, как может предположить, не сбросит наши пользовательские домены, это просто перезагружает домены Redhat и Manageiq.

=== The ManageIQ Coding Style and Standards Guide

Существует http://manageiq.org/documentation/development/coding_style_and_standards/tmanageiq Стиль кодирования и руководство по стандартам] и
https://github.com/manageiq/ruby-style-guide-- Руководство по стилю]. Хотя руководства специально не относятся к автоматизации стиля кодирования (это скорее руководство по разработке управления кодом), мы можем принять рекомендации по сохранению чистых и соответствия нашего кода.

Руководства рекомендуют использовать Snake_case для символов, методов и переменных, а также Camelcase для классов и модулей. Хотя это явно не относится к автоматизации классов и методов данных, мы также можем принять те же рекомендации для нашего кода.

[TIP]
Руководство по стилю в настоящее время не упоминает, должны ли мы назвать экземпляры в Camelcase или Snake_case. Хотя большая часть существующего кода в автоматическом хранилище данных использует именование Camelcase для экземпляров, из CloudForms 4.1/Manageiq _Darga_, и и дальше все новые экземпляры и методы должны быть названы в Snake_case.

=== Defensive Programming

Динамический характер структуры объекта означает, что мы должны быть более осторожны в тестировании на условия * NIL *, проверяя, существуют ли хэш -клавиши перед тем, как мы получаем доступ к ним, проверяют, перечисляются ли переменные, прежде чем мы вызовут + каждый + на них, и так далее.

Некоторые примеры:

[source,ruby]
----
Если это_обект.respond_to? (: атрибуты)
Если this_object.attributes.respond_to? :каждый
this_object.attributes.each do | ключ, значение |
      ...
----

[source,ruby]
----
user = $ evm.root ['user'] rescue nil
Если только user.nil?
  ...
----

[source,ruby]
----
prov = $ evm.root ['miq_provision']
Если prov.options.key? (: ws_values)
ws_values ​​= prov.options [: ws_values]
  ...
----

=== Catch Exceptions

В качестве расширения наконечника _declense Programming_ мы также должны ловить и обрабатывать исключения, где это возможно в наших сценариях. Мы видели несколько примеров этого в сценариях, которые мы изучили в книге, например:

[source,ruby]
----
начинать
...
Rescue RestClient :: exception => err
Если только ERR.Response.nil?
erry = err.response
$ evm.log (: error, «Проблема остановки не удалось с кодом: #{error.code}»)
$ evm.log (: error, "тело ответа было: \ n#{error.body.inspect}")
$ evm.root ['ae_reason'] = "Запрос REST не удался с кодом: #{error.code}"
конец
$ evm.root ['ae_result'] = 'ошибка'
Выход miq_stop
rescue => err
$ evm.log (: error, "[#{err}] \ n#{err.backtrace.join (" \ n ")}")
$ evm.root ['ae_reason'] = "неопределенная ошибка, см. Automation.log для backtrace"
$ evm.root ['ae_result'] = 'ошибка'
Выход miq_stop
конец
----

=== Use an External IDE

Встроенный редактор кода WebUI довольно прост. Часто его легче разрабатывать во внешнем редакторе или IDE, а также копировать и вставить код в встроенный редактор при завершении.

=== Version Control

Интеграция GIT для автоматизации данных была введена в CloudForms 4.2/Manageiq _euwe_.

Несколько консультантов Red Hat US также создали проект с открытым исходным кодом для управления управлением версиями и непрерывной интеграцией (CI) артефактов CloudForms, таких как автоматизация кода и диалогов, по регионам. Сноска: [Код проекта находится https://github.com/rhtconsulting/miq-ci[here]]]

Рабочий процесс CI создается с использованием Jenkins. Он обеспечивает представление о трубопроводе, которое позволяет нам визуализировать, какая версия любого из артефактов находится в любом регионе в определенное время. Мы можем реализовать регионы в качестве этапов жизненного цикла в нашем процессе разработки, таких как Dev, Test, QA и продвижение кода через жизненный цикл по мере развития нашего тестирования (см. << i2 >>).

[[i2]]
. Непрерывная интеграция рабочий процесс для разработки автоматизации управления
image::images/ci_workflow.png[]
{zwsp} +

=== Use Configuration Domains

Мы видели несколько примеров в книге, где системные учетные данные были извлечены из схемы экземпляра с использованием `$ evm.Object ['' attribute ']`.

Когда мы работаем над более крупными проектами и реализуем какое -то управление версиями, как описано ранее, у нас будет отдельные установки Manageiq для наших различных средах жизненного цикла кода автоматизации - например, Dev, Test и QA. Вероятно, (и хорошая практика), что учетные данные для подключения к нашим различным службам интеграции будут различными для каждой среды жизненного цикла, но мы хотим иметь возможность «продвигать» наш код через каждую среду с минимальными изменениями.

В этом случае может быть полезно создать отдельный домен _configuration_ для каждой среды жизненного цикла, содержащую чисто классы и экземпляры, которые определяют имена пользователей, пароли или URL -адреса, специфичные для этой среды. Домен конфигурации обычно не содержит методов; Они находятся в тестируемом домене «кода». Когда метод вызывает `$ evm.object ['attribute']`, атрибут извлекается из работающего экземпляра в домене конфигурации, который имеет самый высокий приоритет.

Затем процесс тестирования становится проще, когда мы циклически проводятся в велосипеде в домене кода через каждую среду жизненного цикла, без необходимости изменять какие -либо учетные данные; Они статически определены в домене конфигурации. Процесс проиллюстрирован в << PROMOTING-CODE-DOMAINS-LIFECYCLE-ENVERNMENTS >>

[[promoting-code-domains-through-lifecycle-environments]]
.
[options="header"]
|=======
| Спринты/среды | dev | тест | q/a | prod
| Sprint1 | dev + домены code_v4 | test + code_v3 домены | qa + code_v2 домены | Prod + Code_v1 домены
| Sprint2 | dev + домены code_v5 | test + code_v4 домены | qa + code_v3 домены | prod + code_v2 домены
| Sprint3 | dev + домены code_v6 | test + code_v5 домены | qa + code_v4 домены | prod + домены code_v3
|=======

=== Summary

Это завершает наше исследование возможностей автоматизации облачныхформ и управления. В предыдущих главах мы узнали об автоматическом хранилище данных и объектах, которые мы используем для создания наших сценариев автоматизации. Мы посмотрели за кулисы на объекты, с которыми мы работаем, и узнали об их атрибутах, виртуальных столбцах, ассоциациях и методах.

Мы обнаружили, как эти компоненты объединяются для создания рабочих процессов, которые обеспечивают виртуальные машины и облачные экземпляры инфраструктуры, и мы увидели примеры того, как мы можем настроить предварительные государственные машины для наших собственных целей.

Мы создали каталоги сервисов для развертывания серверов как по отдельности, так и в пакетах, и мы интегрировали наши автоматические рабочие процессы с внешним сервером Red Hat Satellite 6.2.

Мы видели, как CloudForms и Manageiq могут управлять всем нашим жизненным циклом виртуальной машины, включая пенсию, и мы изучили процесс выхода на пенсию для виртуальных машин и услуг.

Мы посмотрели на возможности автоматизации _integration_ и увидели, как легко мы можем интегрировать наши рабочие процессы автоматизации с нашим более широким предприятием.

Наше путешествие к мастерству автоматизации завершено. Все, что осталось, - это практиковать и начать автоматизировать!
