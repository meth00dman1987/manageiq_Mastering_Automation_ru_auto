[[automation-request-approval]]
== Утверждение запроса на автоматизацию

В ссылке: ../ Calling_Automation_USING_THE_RESTFUL_API/gupt.asciidoc [Автоматизация вызовов с использованием API RESTFUL] Мы рассмотрели, как внешние системы могут использовать рабочие процессы Manageiq Automate, вызывая API Restful. В примерах мы указали `: auto_approve => true` в остальном вызове, чтобы наши запросы были немедленно обработаны, однако мы можем автоматически одобрить наши собственные запросы, только если мы аутентифицируем подлинность как пользователь администратора.

Внедрение полномочий администраторов в наши внешние (вызывные) сценарии, как правило, считается неразумным, но если мы все еще хотим, чтобы наши запросы на автоматизацию были автоматически одобрены, что мы можем сделать?

К счастью, на этом этапе в книге мы узнали достаточно, чтобы иметь возможность реализовать наш собственный рабочий процесс одобрения для запросов на автоматизацию. В примере в этой главе используется профиль группы управления доступом для управления тем, какие группы могут отправлять автоматические запросы на автоматизацию.

=== Implementing a Custom Approval Workflow

Наши рабочие процессы одобрения запроса на автоматизацию будут следовать очень сходной схеме для одобрения запроса о предоставлении, и мы повторно используем и адаптируем несколько компонентов. Мы реализуем два рабочего процесса; Один из них запустил из события * request_created *, и один из события * request_pending * (см. << i10 >>).

[[i10]]
.EVENT-инициализированный запрос на автоматизацию рабочие процессы
image::images/workflow.png[Screenshot,400,align="center"]
{zwsp} +

Прежде чем мы реализуем что -то, что нам нужно для создания новых компонентов автоматизации данных для данных для удержания наших объектов рабочего процесса.

==== Namespace

Мы создадим новое пространство имен под названием _Automation_ в нашем собственном домене.

==== Group Profile

Мы создадим простой вариант профиля группы виртуальной машины (мы можем скопировать это из домена Manageiq и отредактировать его). Наш класс профиля будет содержать два экземпляра (профили), __bit63group_vm_user__ и _.missing_ (см. << i1 >>).

[[i1]]
. Профили группы одобрения
image::images/ss1.png[Screenshot,350,align="center"]
{zwsp} +

Профиль просто содержит имя экземпляра машины состояния автоматического одобрения, который будет использоваться для определения того, является ли запрос автоматически одобрен. Профиль запрашивается с использованием сообщения ** get_auto_approval_state_machine_instance ** и возвращает поле _value_ через _collect_ as **/state_machine_instance **.

Мы позволим участникам группы _bit63group_vm_user_, чтобы они были автоматическими, и все остальные (включая администраторов, которые не указали `: auto_approve => true`), потребуют явного одобрения.

Профиль для группы _bit63group_vm_user_ показан в << i2 >>.

[[i2]]
.Profile схема для группы bit63group_vm_user
image::images/ss3.png[Screenshot,700,align="center"]
{zwsp} +

Профиль _.missing_ для всех других групп показан в << i3 >>.

[[i3]]
.Profile схема для.
image::images/ss2.png[Screenshot,700,align="center"]
{zwsp} +

==== State Machine

Мы создадим пространство имен _stateMachines_ и простой вариант класса VM _ProvisionRequestApproval_. Мы скопируем класс _provisionRequestApproval_ из домена Manageiq в наш под новым _statemachines_ -пространством имен и назваем его _AutomationRequestApproval_. Мы также скопируем связанные с ними экземпляры и методы (см. << i4 >>).

[[i4]]
.AutomationRequestApprovalcom Примеры и методы
image::images/ss4.png[Screenshot,350,align="center"]
{zwsp} +

===== Instances

Экземпляр _RequireAppRoval_ имеет значение * approval_type * __require_pproval__ (см. << i5 >>).

[[i5]]
.Fields от экземпляра требований
image::images/ss5.png[Screenshot,550,align="center"]
{zwsp} +

Экземпляр _auto_ похож, но имеет значение * ancessul_type * __auto__.

[[methods]]
===== Methods

Метод _validate_request_ выглядит следующим образом:

[source,ruby]
----
запрос = $ evm.root ['miq_request']
ресурс = request.resource
Поднимите «запрос на автоматизацию не найден», если запрос.nil? || resource.nil?

$ evm.log ("info", "Проверка на Auto_proval")
advance_type = $ evm.object ['antecure_type']. Downcase
if approval_type == 'Auto'
$ evm.root ["miq_request"].
$ evm.root ['ae_result'] = 'ok'
еще
MSG = "Запрос не был автоматически одобрен"
resource.set_message (msg)
$ evm.root ['ae_result'] = 'ошибка'
$ evm.object ['anues'] = msg
конец
----

Метод _pending_request_ выглядит следующим образом:

[source,ruby]
----
#
# Этот метод выполняется, когда запрос на автоматизацию не одобрен автоматическим
#
# Получить объекты
msg = $ evm.object ['anuest']
$ evm.log ('info', "#{msg}")

# Повышение события автоматизации: request_pending
$ evm.root ["miq_request"]. В ожидании
----

Определению метода также предоставляется входной параметр с входным именем *Причина *и тип данных *Строка *

Метод + uppure_request + выглядит следующим образом:

[source,ruby]
----
#
# Этот метод выполняется, когда запрос автоматизации является автоматическим одобрением
#
# Автоподобный запрос
$ evm.log («info», «Автоматическое запрос на автоматизацию»)
$ evm.root ["miq_request"].
----

==== Email Classes

Мы создаем класс _EMAIL_ с помощью экземпляра _AutomationRequest_pending_ и метода (см. << i6 >>).

[[i6]]
.Mail классов и методов
image::images/ss6.png[Screenshot,350,align="center"]
{zwsp} +

Код метода копируется и адаптируется в зависимости от метода VM _ProvisionRequest_pending_. Мы указываем как * to_email_address * Пользователь, который будет выступать в качестве утвержденного для запросов на автоматизацию.

Полный код для методов
https://github.com/pemcg/mastering-automation-in-cloudforms-4.2-and-manageiq-euwe/tree/master/automation_request_pprovolvom/scripts= shere]

=== Policies

Нам нужно генерировать экземпляры политики для двух событий AutomationRequest, *AutomationRequest_created *и *AutomationRequest_Approved *. Мы копируем стандартный _/system/police_ класс в наш домен и добавляем два экземпляра (см. << i7 >>).

[[i7]]
.New Policy Extances
image::images/ss7.png[Screenshot,350,align="center"]
{zwsp} +

==== AutomationRequest_created

Наш экземпляр политики для _AutomationRequest_created_ имеет три записи; утверждение и две отношения. Нам нужно признать, был ли предъявлен запрос на автоматизацию с параметром `: auto_approve => true`. Если бы это было так, нам нужно пропустить наш собственный рабочий процесс утверждения.

Мы знаем (из какой -либо следственной отладки с использованием _objectwalker_), что, когда выполняется запрос, указывает `: auto_approve => true`, у нас есть` $ evm.root ['Automation_Request']. Когда выполняется запрос, определяет `: auto_approve => false` Это значение ** pending_approval **. Поэтому мы можем создать наше утверждение для поиска `$ evm.root ['Automation_Request'].

Отношение * REL1 * этого экземпляра выполняет поиск профиля на основе нашей группы пользователей, чтобы найти экземпляр состояния автоматического одобрения, который следует запускать. Отношения * rel2 * вызывает этот экземпляр машины штата (см. << i8 >>).

[[i8]]
.Fields of AutomationRequest_created
image::images/ss8.png[Screenshot,700,align="center"]
{zwsp} +

==== AutomationRequest_pending

Экземпляр _AutomationRequest_pending_ содержит одно отношение к нашему экземпляру _AutomationRequest_pending_ (см. << i9 >>).

[[i9]]
.Fields экземпляра AutomationRequest_pending
image::images/ss9.png[Screenshot,500,align="center"]
{zwsp} +

=== Testing

Мы отправим три запроса автоматизации через API Restful, вызывая простой экземпляр _test_. Звонки будут сделаны следующим образом:

* Как пользователь __admin__, указание `: auto_approve => true`
* Как пользователь __admin__, указание `: auto_approve => false`
* Как пользователь, который является членом группы _bit63group_vm_user_

Для первого звонка наше утверждение правильно предотвращает запуск нашего рабочего процесса по собственному утверждению (запрос уже был автоматически одобрен). От _automation.log_ мы видим:

....
Оценка замещенного утверждения ["Утверждено" == "wending_pploval"]
Утверждение не удалось: <"Утверждено" == "dend_pesproval">
Следуйте отношению [miqaedb:/system/policy/AutomationRequest_created#create]
Следуют отношения [miqaedb:/system/police/request_created#create]
Следуйте отношению [miqaedb:/system/event/request_created#create]
....

Для второго звонка мы видим, что утверждение сводит к ** true **, но группа пользователя __admin __ (__evmgroup-super_administrator__) не имеет профиля группы. Используется профиль + .missing +, а запрос на автоматизацию не одобрен автоматическим.

Пользователь _Admin_ получает электронное письмо:

....
Запрос не был автоматически одобрен.

Пожалуйста, просмотрите ваш запрос и обновите или дождите одобрения от администратора.

Чтобы просмотреть этот запрос, перейдите по адресу: https://192.168.1.45/miq_request/show/125

Спасибо,
Команда инфраструктуры виртуализации
....

Пользователь _proving_ также получает электронное письмо:

....
Утверждает,
Запрос на автоматизацию, полученный с admin@bit63.com, находится на рассмотрении.

Запрос не был автоматически одобрен.

Для получения дополнительной информации вы можете перейти к: https://192.168.1.45/miq_request/show/125

Спасибо,
Команда инфраструктуры виртуализации
....

Нажатие на ссылку перенесет нас на страницу утверждения, и мы можем одобрить запрос, который затем продолжается.

Для третьего звонка мы видим, что утверждение оценивается с ** true **, но на этот раз мы видим, как используется действительный профиль группы:

....
Оценка замещенного утверждения ["pending_proval" == "pending_proval"]
Следующие отношения [miqaedb:/Automation/profile/bit63group_vm_user#get_auto ..
....

Профиль этой группы автоматически одобряет запрос на автоматизацию, и экземпляр _test_ успешно запускается:

....
Q-task_id ([Automation_task_186]) \
<Aemethod test> Вызов метода тестирования был успешным!
....

Успех!

=== Summary

В этой главе мы собрали многие из автоматических компонентов, которые мы изучали на протяжении всей книги, чтобы создать наш собственный рабочий процесс утверждения. Мы сделали это, копировав и адаптировав несколько существующих компонентов в домене Manageiq и добавив наши собственные части, где это необходимо.

Мы начали с создания нашего собственного пространства имен для работы, и добавили профиль группы управления доступом, чтобы мы могли применить автоматическое одобрение к конкретным группам. Мы клонировали класс _provisionRequestApproval_ и его методы, чтобы стать нашей машиной _AutomationRequestApproval_, и мы создали два экземпляра, один из которых назывался _Auto_, и один называется _RequireApproval_. Мы добавили класс _email_ и клонировали и адаптировали экземпляр _provisionrequest_pending_ и метод, чтобы стать нашим версиями _automationrequest_pending_. Наконец, мы добавили два экземпляра политики для обработки двух событий Automation * request_created * и * request_pending *.

Создание одобрения рабочего процесса, такого как это, на самом деле является просто случаем создания кусочков и соединения его вместе. Мы знаем, что рабочие процессы утверждения начинаются с события, и что событие переводится в политику. Пока экземпляры нашей политики направляют рабочий процесс в соответствующие обработчики (как правило, государственный компьютер или класс электронной почты), все, что осталось, - это адаптировать код метода к нашим конкретным целям и тестирование.

