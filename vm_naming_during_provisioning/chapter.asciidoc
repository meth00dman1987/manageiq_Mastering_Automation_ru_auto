[[vm-naming-during-provisioning]]
== Наименование виртуальной машины во время обеспечения

Когда мы предоставляем виртуальную машину с использованием нативного менеджера провайдера - VMware VSphere или, например, Manager Virtuization Virtuization Enterprise, - мы должны предоставить имя новой виртуальной машины. Одним из преимуществ платформы управления облаком, такой как CloudForms или ManageiQ, является то, что мы можем частично или полностью автоматизировать создание имен виртуальных машин в рамках рабочего процесса обеспечения.

CloudForms и Manageiq имеют очень гибкие способы позволить нам назначать имена виртуальным машинам во время обеспечения, в процессе, известном как _naming_. Они позволяют нам явно назвать виртуальную машину (штраф для операций по обеспечению одноклеточного VM) или автоматически применить номер с нулевым прибором для запросов на предоставление с несколькими VM. Они также позволяют нам использовать или создавать пользовательскую политику именования, в которой имена виртуальных машин автогенерируются на основе ряда факторов, включая, например, общий префикс, теги или членство в группе.

=== VM Name-related Provisioning Options

Процесс именования имеет несколько входов и обычно два выхода. _Inputs_ в процессе именования представляют собой ряд переменных и символов, которые установлены (и мы можем настроить) во время диалогового окна обеспечения или определены в схеме класса _naming_. _Outputs_ из процесса именования являются именем виртуальной машины и, необязательно имя хоста (то есть первая часть FQDN), которая будет применена к операционной системе виртуальной машины.

==== Inputs to the Naming Process

В следующих подразделах подробно описываются переменные и символы, используемые в качестве входов в виртуальную машину
логика именования.

===== vm_name

`vm_name` дается значение из имени * vm * box in * provision virtual Machines -> Catalog * (см. << i1 >>).

[[i1]]
. Постановка на имя виртуальной машины во время обеспечения
image::images/ss1.png[Screenshot,450,align="center"]
{zwsp} +

Символ добавляется в _Request_ опции хэш как:

[source,ruby]
----
miq_provision_request.options [: vm_name]
----

===== vm_prefix

`vm_prefix` может использоваться для создания пользовательского имени виртуальной реальности и считывается из переменной * vm_prefix * в схеме экземпляра именования (по умолчанию« cfme », но мы можем определить нашу собственную, если это необходимо) (см. << i2 >>).

[[i2]]
. Определение значения VM_PREFIX в экземпляре именования по умолчанию
image::images/ss2.png[Screenshot,500,align="center"]
{zwsp} +

В качестве альтернативы мы можем установить значение в _Request_ hash:

[source,ruby]
----
miq_provision_request.options [: vm_prefix]
----

===== hostname

`hostname` дается значение * name * host * in * virtual Machines -> Настройка * (см. << i3 >>).

[[i3]]
. ПРЕДЛОЖЕНИЕ ДЛЯ ИМЯ ВВС во время обеспечения
image::images/ss3.png[Screenshot,400,align="center"]
{zwsp} +

Символ добавляется в _Request_ опции хэш как:

[source,ruby]
----
miq_provision_request.options [: hostname]
----

===== linux_host_name

Если используется спецификация настройки VMware для Linux, `linux_host_name` - это _specific name_, извлеченное из шаблона. Логика имен использует это для установки имени хоста операционной системы.

Символ добавляется в _Request_ опции хэш как:

[source,ruby]
----
miq_provision_request.options [: linux_host_name]
----

===== sysprep_computer_name

Если используется спецификация настройки VMware для Windows, `sysprep_computer_name` - это _specific name_, извлеченное из шаблона. Наименование Manageiq использует это в качестве ввода в процесс SYSPREP, чтобы установить имя NetBios.

Символ добавляется в _Request_ опции хэш как:

[source,ruby]
----
miq_provision_request.options [: sysprep_computer_name]
----

===== miq_force_unique_name

`miq_force_unique_name` используется внутренне при обеспечении виртуальных машин из каталога услуг. Когда MIQ_Provision _TASK_ создается для положения VM Catalog, его клавиша HASH с параметрами устанавливается как:

[source,ruby]
----
miq_provision.options [: miq_force_unique_name] = [true, 1]
----

==== Outputs from the Naming Process

Символы, обсуждаемые в следующих подразделах, получены с помощью именования виртуальной машины
Метод и добавлен в _task_ hash hash.

===== vm_target_name 

`vm_target_name` представляет новое имя виртуальной машины. Он добавлен в хэш _task_ hash как:

[source,ruby]
----
miq_provision.options [: vm_target_name]
----

===== vm_target_hostname

`vm_target_hostname` - это VM $ (HOSTNAME), назначенная на выводе логики именования виртуальной машины (15 символов для Windows, 63 символов для Linux). Он добавлен в хэш _task_ hash как:

[source,ruby]
----
miq_provision.options [: vm_target_hostname]
----

=== Name Processing

Большая часть логики именования виртуальной машины происходит в коде Rails, который не подвергается воздействию двигателя автоматизации. Этот код, однако, вызывает экземпляр/метод именования, определяемый в профиле группы Provisioning (поле * vmname *), и мы можем использовать это для добавления наших собственных настроек. Метод именованного профиля записывает свое предложенное имя в `$ evm.object ['vmname']`, которое распространяется обратно на метод внутренних рельсов с помощью сбора.

Если определяемый профилем метод именования предлагает имя, которое следует численно суффикс (например, `#{vm_name} $ n {3}`), то код первых рельсов выделяет следующий бесплатный номер в последовательности и формирует имя виртуальной машины.

Определенный профиль метод именования по умолчанию для инфраструктуры VMS в Manageiq _capablanca_ IS _/Инфраструктура/VM/Provisioning/Naming/vmname_. Это относительно простой метод следующим образом:

[source,ruby]
----
#
# Описание: это метод Vmnaming по умолчанию
# 1. Если имя виртуальной машины не было выбрано во время обработки диалога, используйте VM_PREFIX
# из Dialog Else Используйте модель и тег [: Environment] для создания имени
# 2. Весе используйте имя виртуальной машины, выбранное в диалоге
# 3. Затем добавьте 3 -значный суффикс в vm_name
# 4. Добавлена ​​поддержка динамического именования услуг
#

$ evm.log ("info", "DeTicted vmdb_object_type: <#{$ evm.root ['vmdb_object_type']}>")

prov = $ evm.root ['miq_provision_request'] || \
$ evm.root ['miq_provision'] || \
$ evm.root ['miq_provision_request_template']

vm_name = prov.get_option (: vm_name) .to_s.strip
number_of_vms_being_provisioned = prov.get_option (: number_of_vms)
diamethod = prov.get_option (: vm_prefix) .to_s.strip

# Если во время диалога не было выбрано имя виртуальной машины
Если vm_name.blank? || vm_name == 'Changeme'
vm_prefix = nil
vm_prefix || = $ evm.object ['vm_prefix']
$ evm.log ("info", "vm_name из Dialog: <#{vm_name.inspect}> \
vm_prefix из диалога: <#{diamethod.inspect}> \
vm_prefix из модели: <#{vm_prefix.inspect}> ")

# Получить теги для подготовки к имени виртуальной машины
теги = prov.get_tags
$ evm.log ("info", "Tags объекта: #{tags.inspect}")

# Установите префикс для именования виртуальной машины
Если Diamethod.blank?
vm_name = vm_prefix
еще
vm_name = diamethod
конец
$ evm.log ("info", "Префикс именования виртуальной машины: <#{vm_name}>")

# Проверка: тег среды
env = теги [: среда]

# Если тег среды не ноль
Если только Env.Nil?
$ evm.log ("info", "Тег среды: <#{env}> обнаружен")
# Получите первые 3 символа: тег среды
env_first = env [0, 3]

vm_name = "#{vm_name}#{env_first}"
$ evm.log ("info", "Обновление имени виртуальной машины: <#{vm_name}>")
конец
defived_name = "#{vm_name} $ n {3}"
еще
if number_of_vms_being_provisioned == 1
defived_name = "#{vm_name}"
еще
defived_name = "#{vm_name} $ n {3}"
конец
конец

$ evm.object ['vmname'] = derived_name
$ evm.log ("info", "vm name: <#{derived_name}>")
----

Если мы рассмотрим этот код, мы сможем увидеть логику, которую методы именования виртуальной машины используют для определения имен. Есть два основных условия, следующим образом.

==== Provisioning a Single VM or Instance

Обеспечение одной виртуальной машины из * инфраструктуры -> виртуальных машин -> LifeCycle -> Provision VMS * или из каталога услуг приведет к тому, что виртуальная машина будет предоставлена ​​значение `: vm_name`, если vm_name` не является пустым или имеет значение« Changeme ». Если `: vm_name` является пустым или« Changeme », то мы проходим через логику в методе именования двигателя автоматизации, который собирает имя виртуальной машины, объединяя значение`: vm_prefix` с первыми 3 символами `: Environment`-тега (если он существует) и добавив три цифровых цифр.

==== Provisioning Multiple VMs or Instances in a Single Request

Обеспечение нескольких серверов из каталога услуг приведет к символу `: miq_force_unique_name`, установленное на истину для каждого _task_. Если `: vm_name` не является пустым или« Changeme », то серверы будут названы как`: vm_name` с «_n \ {4}», добавленным, например, Server_0001, Server_0002 и т. Д. Согласно логике во внутренних рельсах класса `miqprovision :: naming`. В этом сценарии метод именования, определенный профиль, не используется.

Обеспечение нескольких серверов из * инфраструктуры -> Виртуальные машины -> LifeCycle -> Provision VMS * не приведет к `: miq_force_unique_name`, установленное на истину, и будет применяться логика именования виртуальной машины в методе именования, определяемого профилем. Серверам будет предоставлено значение `: vm_name`, добавленное три цифры с нулевым плащом, например, Server001, Server002 и т. Д.

=== Customising the Naming Process

Мы часто хотим настроить процесс именования для наших собственных требований. Например, мы можем пожелать назвать все серверы, используя фиксированный префикс (`: vm_prefix`), за которым следует значение тега * server_role *, за которым следует расширение цифр с нулевой платой. Мы можем сделать это, используя небольшую модификацию метода именования, определяемого профилем, в сочетании с маркировкой серверов, которые мы хотим для специального приема:

[source,ruby]
----
...
prefix = prov.get_option (: vm_prefix) .to_s.strip
#
# Специальный случай. Любые серверы с меткой "Server_role" - PEMCG
#
# Получить теги для подготовки к имени виртуальной машины
теги = prov.get_tags
#
# Проверка: тег Server_role
#
server_role = теги [: server_role]
Если не Server_role.nil?
defived_name = "#{prefix}#{server_role} $ n {2}"
$ evm.object ['vmname'] = derived_name
$ evm.log ("info", "#{ @method} - vm name: <#{dearived_name}>"), если @debug
  #
# Метод выхода
  #
$ evm.log ("info", "#{@method} - EVM Automate Method завершился")
Выход miq_ok
конец
#
# Конец специального случая для серверов с меткой "server_role"
#
...
----

Мы можем сделать это, копировав экземпляр _/инфраструктура/VM/Provisioning/Naming/default_ и метод _/инфраструктура/vm/provisioning/naming/vmname_ в нашем домене и соответственно редактирование схемы или метода.

=== Summary

Как мы уже видели, процесс именования виртуальных машин очень гибкий и позволяет нам создавать пользовательскую схему именования для нашей облачной или виртуальной инфраструктуры. Логика именования вызывается во время обработки профиля группы во время обеспечения, поэтому различные группы пользователей могут иметь совершенно разные схемы именования виртуальных машин, если мы захотим.

Мы также видели, что процесс именования генерирует операционную систему _hostnames_, а также имена виртуальных машин. Установка имени хоста - это функция операционной системы (а не контейнер виртуальных машин), поэтому мы должны передать это значение какому -либо другому процессу для его установки.

Если мы загружаем наши новые виртуальные машины Red Hat и выполняем установку Kickstart, то мы можем ввести значение имени хоста в сценарий Kickstart во время выполнения. Если мы готовимся из полностью настроенных шаблонов, нам необходимо использовать VMware _customization Speciation_ или сценарий Cloud-INIT для выполнения инъекции имени хоста.

==== Further Reading

https://access.redhat.com/articles/349393* Hat CloudForms Management Engine PXE и ​​ISO Provisioning с RHEV]

https://technet.microsoft.com/en-us/library/cc959336.aspx?f=255&mspperror=-2147217396. Согласно ограничениям имени для хостов и доменов]

https://blog.serverdency.com/picking-server-hostnames/tspicking server имена хост-штанги]
