[[ways-of-entering-automate]]
== способы ввода автоматизации

Мы начинаем видеть, насколько мощным может быть автоматизатор, поэтому давайте посмотрим на различные способы, которыми мы можем инициировать операцию автоматизации.

Существует шесть методов, которые мы обычно используем для запуска в автоматизацию для запуска наших экземпляров или инициировать наши пользовательские рабочие процессы. Метод, который мы выбираем, определяет точку ввода автоматизации данных и объекты, которые доступны для нашего метода при запуске.

=== Buttons and Simulation

До сих пор мы запустили сценарии автоматизации двумя способами: из ** моделирования ** и из пользовательской кнопки. С любым из этих методов нам был представлен раскрывающий список точек входа в _/system/process_ в автоматическое хранилище данных (см. << i1 >>).

[[i1]]
.ENTRY указывает в автоматизированное хранилище данных от симуляции
image::images/ss4.png[screenshot,450,align="center"]
{zwsp} +

На практике мы используем только _/system/process/request_ для запуска наших собственных запросов автоматизации из кнопки или симуляции. Записи в _/system/process/request_ get перенаправлено на имя * запроса * экземпляра, которое мы указали с помощью вызова, который должен быть экземпляром в пространстве имен equest_ request_. В наших примерах до сих пор мы использовали * запрос * экземпляры _call_instance_ и _addcustomattribute_ (который мы добавили в наш домен _acme_).

[NOTE]
====
Использование _/system/process/event_ изменилось с Manageiq _capablanca_. Нам нужно было бы передать объект _eventStream_ с нашим запросом на использование этой точки записи.

Точка входа _/system/process/Automation_ используется внутренне, когда _tasks_ создаются для таких операций, как обеспечение виртуальной машины или выхода на пенсию:

----
Компания [/System/Process/Automation? \
Miqprovision%3a%3amiq_provision = 100000000000091 & \
Miqserver%3a%3amiq_server = 1000000000001 & \
Пользователь%3A%3Auser = 100000000000001 & \
object_name = Automation & \
request = vm_provision & \
vmdb_object_type = miq_provision]
----
====

=== RESTful API

Мы можем инициировать операцию автоматизации, используя API RESTFUL (см. Ссылку: ../ Calling_Automation_USING_THE_RESTFUL_API/grail.asciidoc [Автоматизация вызова с использованием API RESTFUL] для получения более подробной информации). В этом случае мы можем непосредственно вызывать любой экземпляр в любом месте в автоматическом хранилище данных, нам не нужно вызывать _/system/process/request_.

=== Control Policy Actions

Можно создать _control Policy Action_, который запускает пользовательский экземпляр автоматизации (см. << i2 >>).

[[i2]]
. Обивание пользовательской автоматизации в качестве управления действием
image::images/ss1.png[screenshot,400,align="center"]
{zwsp} +

Это может запустить любой экземпляр в _/system/request_, но, как и прежде, мы можем использовать _call_instance_ для перенаправления вызова через встроенное * rel2 * отношение к экземпляру в нашем собственном домене и пространстве имен.

=== Alerts

Мы можем создать _Alert_, который отправляет _Management Event_. Поле * Имя события * соответствует имени экземпляра, который мы создаем для обработки оповещения. (См. << i3 >>).

[[i3]]
.
image::images/ss2.png[ch11_ss,400,align="center"]
{zwsp} +

Имя события соответствует экземпляру в коммутаторе событий в рамках _/System/Event/Customevent/Alert_. Мы можем клонировать _/system/event/customevent/alert_pace имен в наш собственный домен и добавить соответствующий экземпляр (см. << i4 >>).

[[i4]]
. Выдвигая экземпляр для обработки мероприятия по управлению предупреждением
image::images/ss3.png[screenshot,300,align="center"]
{zwsp} +

Этот экземпляр теперь будет запущен, когда предупреждение будет запускается.

=== Service Dialog Dynamic Elements

Мы можем запустить экземпляр автоматизации в любом месте в автоматическом хранилище данных из диалогового диалога динамического обслуживания. На практике этот тип скрипта разработан специально для заполнения элемента, и мы не будем запускать общий рабочий процесс таким образом. Мы освещаем элементы диалога динамического обслуживания больше в ссылке: ../ service_dialogs/gupt.asciidoc [Dialogs Service].

=== Finding Out How Our Method Has Been Called

Наша точка входа в Automate регулирует содержание `$ evm.root` - это объект, чей экземпляр превратил нас в автоматизацию. Если мы напишем общий полезный метод, такой как тот, который добавляет диск к виртуальной машине, может быть полезно, чтобы иметь возможность назвать его несколькими способами, не обязательно зная, что может содержать `$ evm.root '.

Например, мы могли бы добавить диск во время обеспечения рабочего процесса для виртуальной машины; из кнопки на существующем объекте виртуальной машины в веб -салоне или даже от внешнего вызова RESTFUL в двигатель автоматизации, передавая идентификатор виртуальной машины в качестве аргумента. Содержание `$ evm.root's различено в каждом из этих случаев.

Для каждого из этих случаев нам нужно получить доступ к целевому объекту VM по -разному, но мы можем использовать ключ «$ evm.root ['vmdb_object_type']», чтобы помочь нам установить контекст:

[source,ruby]
----
case $ evm.root ['vmdb_object_type']
Когда «miq_provision ' # вызовет из рабочего процесса по обеспечению виртуальной машины
vm = $ evm.root ['miq_provision']. назначение
  ...
Когда 'vm'
vm = $ evm.root ['vm'] # Вызовов из кнопки
  ...
Когда вызов # Automation_task ' #
attrs = $ evm.root ['Automation_task']. Параметры [: attrs]
vm_id = attrs [: vm_id]
vm = $ evm.vmdb ('vm'). find_by_id (vm_id)
  ...
конец
----

=== Summary

В этой главе мы узнали различные способы ввода автоматизации и начать запускать наши сценарии. Мы также узнали, как создавать общие полезные методы, которые можно назвать несколькими способами, и как установить их работает контекст с использованием `$ evm.root ['vmdb_object_type']`.

Многие из автоматических методов, которые мы пишем, можно использовать в нескольких различных контекстах; как часть рабочего процесса, обеспечивающего виртуальную машину, или, например, из кнопки. Они могут запускать из первого случая, вызванного при вводе автоматизации, или через отношения в другом экземпляре, уже работающем в двигателе автоматизации. Этот экземпляр может быть даже государственной машиной (мы обсуждаем государственные машины в ссылке: ../ state_machines/gupt.asciidoc [государственные машины]), и в этом случае нам может потребоваться сигнализировать о состоянии выхода, используя `$ evm.root ['ae_result']`:

[source,ruby]
----
# Нормальный выход
$ evm.root ['ae_result'] = 'ok'
Выход miq_ok
rescue => err
$ evm.root ['ae_result'] = 'ошибка'
$ evm.root ['ae_reason'] = "неопределенная ошибка, см. Automation.log для backtrace"
Выход miq_stop
----

Если мы учитываем все эти возможные факторы, когда пишем наши сценарии, мы добавляем гибкость в том, как их можно использовать и вызвать. Мы увеличиваем повторное использование кода и уменьшаем разрастание нескольких аналогичных сценариев в наших пользовательских доменах.


