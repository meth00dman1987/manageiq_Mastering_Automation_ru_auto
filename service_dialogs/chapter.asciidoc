[[service-dialogs]]
== Диалоги обслуживания

Когда мы разрабатываем наши услуги в CloudForms или Manageiq, мы стараемся как можно больше упростить процесс заказа для наших пользователей. Мы предварительно зафигурируем как можно больше вариантов подготовки, и в идеале предлагаем небольшой выбор параметров в форме _service Dialog_, чтобы позволить нашим пользователям настроить свой запрос на обслуживание. Примером может предложить простой стиль заказа «размер футболки», чтобы указать размер виртуальной машины (см. << i1 >>).

[[i1]]
. Заказ виртуальных машин в размерах «футболки»
image::images/ss1.png[Screenshot,450,align="center"]
{zwsp} +

Мы уже видели, как создать простой диалог службы в ссылке: ../ Working_with_virtual_machines/grap.asciidoc [работа с виртуальными машинами]. В этой главе будут обсуждаться диалоги с обслуживания более подробно и показывать, как мы можем создавать _dynamic elements_, которые заполняются во время выполнения, когда пользователь заказывает элемент каталога.

=== Dialog Elements

Диалог службы, который мы создали в ссылке: ../ worky_with_virtual_machines/grail.asciidoc [работа с виртуальными машинами] использовал два простых элемента _text box_. В дополнение к текстовым полям, есть несколько других типов элементов, которые мы можем использовать (см. << i2 >>).

[[i2]]
. Доступные типы элементов диалога
image::images/ss2.png[Screenshot,380,align="center"]
{zwsp} +

Элементы диалога сервиса приобрели несколько полезных новых функций с недавними версиями Manageiq, как мы увидим в этой главе.

=== Dynamic Elements

До CloudForms 3.2/Manageiq _botvinnik_ только один тип элемента был способен к динамической (средней) популяции, ** динамический раскрывающийся список **. _Botvinnik_ расширил динамические возможности популяции на большинство других типов диалоговых элементов, поэтому * динамический раскрывающийся список * был удален как отдельный тип элемента.

Динамические элементы заполняются из метода, называемого либо при первоначальном отображении сервисного диалога, либо из необязательной * кнопки «Обновление» (динамические элементы также могут быть авторерированы, как мы увидим вскоре). URI для метода указывается, когда мы добавляем элемент, и выбираем флажок, чтобы сделать его динамичным.

==== Populating the Dynamic Fields

Динамический элемент имеет свой собственный `$ evm.object`. Нам нужно заполнить некоторые предопределенные пары хэш -ключа/значения в этом объекте, чтобы определить настройки поля диалога и загрузку данных, которые будут отображаться. Вот пример того, как мы делаем это:

[source,ruby]
----
dialog_field = $ evm.object

# sort_by: значение / описание / нет
dialog_field ["sort_by"] = "value"

# sort_order: восходящее / спуск
dialog_field ["sort_order"] = "

# DATA_TYPE: String / Integer
dialog_field ["data_type"] = "Integer"

# Требуется: true / false
dialog_field ["требуется"] = true

dialog_field ["values"] = {2 => "2GB", 4 => "4GB", 16 => "16GB"}
dialog_field ["default_value"] = 2
----

Если тип динамического элемента является раскрывающимся списком, ключ «значения» этого хэша также является хэшем пар клавиш/значения. Каждая пара клавиш/значения в этом хэш представляет значение, которое будет отображаться в элементе, и соответствующее значение «data_type», которое будет возвращено для автоматизации в качестве диалога ** _ ***, если выбрано этот выбор.

Вот еще один, более реальный пример универсальности динамических элементов:

[source,ruby]
----
values_hash = {}
values_hash ['!'] = '-выберите из списка-'
user_group = $ evm.root ['user']. ldap_group
  #
# Каждый может обеспечить Dev и Uat
  #
values_hash ['dev'] = "Развитие"
values_hash ['uat'] = "Тест принятия пользователя"
if user_group.downcase = ~ /Administrators /
    #
# Администраторы также могут обеспечить Pre-Prod и Prod
    #
values_hash ['pre-prod'] = "premoduction"
values_hash ['prod'] = "Производство"
конец

list_values ​​= {
'sort_by' =>: value,
'data_type' =>: String,
'обязательно' => true,
'values' => values_hash
  }
list_values.each {| ключ, значение | $ evm.object [key] = value}
----

Этот пример заполняет динамический раскрывающий список с средами жизненного цикла инфраструктуры, в которые пользователь может предоставить новую виртуальную машину. Если пользователь является членом группы, содержащей строку «администраторы», то в список добавляются еще две среды: «предварительное производство» и «производство».

[NOTE]
====
Если элемент помечен как * требуется *, то использует '!' Поскольку возврат по умолчанию в значении приглашения будет удовлетворять «обязательное» условие без пользователя, обязательно выберет что-либо из представленного раскрывающегося списка. Это может быть нежелательно. Для * необходимых * элементов предпочтительным вариантом будет использование + nil + в качестве возврата по умолчанию, например:

[source,ruby]
----
values_hash [nil] = '-выберите список-'
----

Это не удовлетворит «требуемое» условие и заставит пользователя выбрать представленное «реальное» значение из раскрывающегося списка.
====

=== Read-Only and Protected Elements

CloudForms 3.1/Manageiq _anand_ добавил возможность отмечать текстовое поле как защищенное, что приводит к тому, что любой ввод запутывается. Это особенно полезно для ввода паролей (см. << i3 >>).

[[i3]]
.Dialog, который подсказывает пароль в защищенном элементе
image::images/ss3.png[Screenshot,480,align="center"]
{zwsp} +

Manageiq _botvinnik_ представил концепцию элементов только для чтения для диалогов службы, которые нельзя изменить после отображения. Наличие текстового поля динамически заполнено, но только для чтения, делает его идеальным для отображения сообщений.

==== Programmatically Populating a Read-Only Text Box

Мы можем использовать динамически заполненные текстовые или текстовые поля для чтения или текстовые области в качестве поля состояния для отображения сообщений. Вот пример заполнения текстового поля с сообщением, в зависимости от того, готовится ли пользователь в Amazon или нет:

[source,ruby]
----
Если $ evm.root ['vm']. vendor.downcase == 'amazon'
status = "Действительно для этого типа виртуальной машины"
еще
Статус = 'НЕПРАВИЛЬНЫЙ для этого типа виртуальной машины'
конец
list_values ​​= {
'обязательно' => true,
'защищен' => false,
'read_only' => true,
'value' => status,
  }
list_values.each do | ключ, значение |
$ evm.object [key] = значение
конец
----

=== Element Validation

CloudForms 3.2/Manageiq _botvinnik_ представил возможность добавлять проверку поля ввода в элементы диалога. В настоящее время единственными типами валидаторов являются*none*или ** регулярное выражение **, но регулярные выражения полезны для проверки ввода для таких значений, как IP -адреса (см. << i4 >>).

[[i4]]
. Правило Validator для элемента IP -адреса
image::images/ss4.png[Screenshot,480,align="center"]
{zwsp} +

=== Using the Input from One Element in Another Element's Dynamic Method

Мы можем связать элементы таким образом, чтобы ввод пользователя в одном элементе мог использоваться последующими динамическими элементами, которые являются _refreshable_. Последующий динамический метод, когда он обновлен, может получить доступ к входному значению первого элемента, используя `$ evm.root ['dialog_elementname']` или `$ evm.object ['dialog_elementname']`. Элементы могут быть обновлены кнопкой * обновить *, но CloudForms 4.0/Manageiq _capablanca_ добавили возможность отмечать динамические элементы с характеристикой * Auto Refresh *. Существует соответствующая характеристика * Автоматическое обновление других полей при изменении *, которые мы можем применить к начальному элементу в начале этой цепочки обновления.

Мы можем использовать это несколькими полезными способами, такими как для заполнения динамического списка на основе входа значения ранее или для создания метода проверки.

==== Example

Ниже приведен пример требования к диалогу с сервисом и то, как оно соответствовало решению.

===== Requirement

У нас есть диалог службы, содержащий элемент текстового поля под названием *tenant_name *. В этот элемент пользователь должен ввести имя нового арендатора OpenStack, который будет создан в каждом из нескольких поставщиков OpenStack. Имя арендатора должно быть уникальным, а в настоящее время не существует ни в одном поставщике.

Мы хотели бы добавить возможность валидации в диалог службы, чтобы убедиться, что имя арендатора уже не существует, прежде чем пользователь нажимает на кнопку * отправить *.

===== Solution

В следующем примере элемент блоки текстовой области только для чтения под названием * Validation * используется для отображения проверки сообщения. Пользователю указано, чтобы нажать кнопку «Обновить *», чтобы проверить свой ввод в поле * tenant_name *.

До тех пор, пока кнопка «Обновить» не нажата, в поле «Валидация * текстовая область» отображается «проверка ...». После того, как кнопка «Обновить» нажата, сообщение об проверке изменяется в зависимости от того, существует ли арендатор или нет.

[source,ruby]
----
display_string = "Validation ... \ n"
Tenant_found = false

Tenant_name = $ evm.root ['dialog_tenant_name']
Если envant_name.length.zero?
Downcase_tenant = tenant_name.gsub (/\ w/, '_'). Downcase
$ evm.vmdb ('cloudtenant'). All.emo Do | арендатор |
Если arenant.name.downcase == lowercase_tenant
Tenant_found = true
display_string += "renant \ '#{tenant.name} \' существует в OpenStack"
display_string += "Провайдер: #{$ evm.vmdb ('ems', tenant.ems_id) .name} \ n"
конец
конец
Если envant_found
display_string += "арендатор \ '#{dowercase_tenant} \' доступен для использования"
конец
конец

list_values ​​= {
'обязательно' => true,
'защищен' => false,
'read_only' => true,
'value' => display_string,
}
list_values.each do | ключ, значение |
$ evm.log (: info "
$ evm.object [key] = значение
конец
Выход miq_ok
----

=== Summary

Эта глава показывает гибкость, которую мы имеем, когда мы строим наши диалоги по обслуживанию. Мы можем использовать динамические методы для предварительной загрузки соответствующих параметров в элементы диалога, тем самым настраивая параметры диалога на основе каждого пользователя. Мы также можем создать текстовые поля подтверждения, которые позволяют пользователям проверять свои входы, и, таким образом, разрешать изменения, если необходимо, прежде чем нажать *отправить *.

Стоит отметить, что динамические методы диалога всегда работают на устройстве WebUI, в которое мы вошли, независимо от того, имеет ли этот прибор _Automation Engine_ Server Set. Это может иметь неожиданные последствия. Наши реальные инсталляции CloudForms или Manageiq могут содержать несколько приборов, распределенных между несколькими _zones_, часто с брандмауэрами между (см. << i5 >>).

[[i5]]
.Typical реальная установка CloudForms с несколькими приборами и зонами
image::images/separated_zones.png[Screenshot,500,align="center"]
{zwsp} +

Если мы напишем метод динамического диалога для извлечения какой -либо информации из внешней системы, мы можем ожидать, что метод будет работать на любом из наших приборов «работника» в зоне нашего поставщика, но это не так. Мы должны убедиться, что брандмауэры зоны Webui позволяют нашим приборам WebUI напрямую подключаться к любым внешним системам, к которым нужен наши методы диалога.

==== Further Reading

https://access.redhat.com/documentation/en/red-hat-cloudforms/version-4.0/provisioning-virtual-machines-and-hosts/#service_dialogs® Диалогов]

https://github.com/manageiq/manageiq/pull/2479= Улучшения диалогасистема]]
