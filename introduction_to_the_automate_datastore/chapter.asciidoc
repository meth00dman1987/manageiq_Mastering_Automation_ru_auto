[[introduction-to-the-automate-datastore]]
== Введение в автоматизирование данных данных

Когда мы используем возможности автоматизации CloudForms/Manageiq, мы пишем сценарии на Ruby Language и используем объекты, которые нам предоставляет _Automation Engine_. Веб-пользовательский интерфейс CloudForms/Manageiq (WebUI) позволяет нам получить доступ к функциональности автоматизации с помощью меню «Автоматизировать * верхнего уровня» (см. << i1 >>).

[[i1]]
Аутомат меню верхнего уровня для CloudForms 4.2
image::images/ss1.png[screenshot,270,align="center"]
{zwsp} +

=== The Automate Explorer

Первый пункт меню, который мы видим, доставляет нас к _explorer_. Это наш визуальный интерфейс в _automate datastore_, и он содержит различные виды автоматических объектов, которые мы будем использовать на протяжении всей этой книги (см. << i2 >>).

[[i2]]
. Аутомат -исследователь
image::images/ss2.png[screenshot,550,align="center"]
{zwsp} +

Прежде чем мы начнем наше путешествие в Learning CloudForms/Manageiq Automate, мы отправимся в экскурсию по автоматическому хранилище данных, чтобы ознакомиться с объектами, которые мы найдем там.

=== The Automate Datastore

Автоматизитное хранилище имеет структуру, подобную каталогу, состоящую из нескольких типов организационной единицы, расположенной в иерархии (см. << i3 >>).

[[i3]]
.Automate Sticks Datastore Styles
image::images/datastore.png[screenshot,300,align="center"]
{zwsp} +

Мы можем посмотреть на каждый из этих типов объекта более подробно.

=== Domains

A _domain_ - это коллекция пространств имен, классов, экземпляров и методов. Проект Manageiq предоставляет один домен _Manageiq_ для всего поставленного кода автоматизации, в то время как Red Hat добавляет дополнительный домен _redhat_, содержащий код добавленного значения для продукта CloudForms. Домены Manageiq и Redhat заблокированы, что указывает на их природу только для чтения, однако мы можем создать новые домены для нашего собственного кода автоматизации. << i2 >> показывает домены по умолчанию, два дополнительных вручную домены: _bit63_ и _debug_ и домен Git-Imported _investigative_debugging_.

Организация нашего собственного кода в пользовательские домены значительно упрощает задачу экспорта и импорта кода (упрощение переносимости кода и повторного использования). Он также оставляет Red Hat или проект Manageiq, чтобы обновлять заблокированный домен с помощью незначительных выпусков, не опасаясь перезагрузки нашей настройки.

[NOTE]
Если мы вошли в CloudForms/ManageiQ в качестве учетной записи в арендаторе дочерних, мы можем увидеть домены, созданные родительским арендатором в автоматическом хранилище данных, но они также будут выглядеть как заблокированные.

==== Domain Priority

Домены с добавлением пользователя могут быть индивидуально включены или отключены и могут быть упорядочены по приоритету таким образом, чтобы, если код существует в одном пути в нескольких доменах (например, _/Cloud/VM/Provisioning/Statemachines_), будет выполнен код в домене с ограниченным приоритетом. Мы можем изменить приоритетный порядок наших доменов с добавленными пользователями, используя меню «Конфигурация» -> Редактировать порядок приоритета доменов * (см. << i4 >>).

[[i4]]
. Редактирование приоритетного порядка доменов
image::images/ss3.png[screenshot,450,align="center"]
{zwsp} +

==== Importing and Exporting Domains

Мы можем экспортировать домены, используя _rake_ из командной строки и импортировать их либо с помощью граблей, либо из веб -и. (Использование Rake позволяет нам указать больше вариантов импорта и экспорта). Типичная линия импорта граблей заключается в следующем:

....
Bin/Rake EVM: Automate: Import yaml_file = bit63.yaml imporm_as = bit63 System = false \
ENADED = TRUE DOMAIN = EXPORT PREERIVE = false
....

===== Importing Domains from a Git Repository

CloudForms 4.2/Manageiq _EUWE_ ввел возможность иметь возможность импортировать домены непосредственно из репозитория GIT. Мы можем указать URL -адрес репозитория и дополнительные учетные данные в меню «Импорт / экспорт», после чего содержание репозитория загружается на прибор с набором роли _GIT Repositories hower_ Womper_. Затем мы можем выбрать импорт из филиала или тега хранилища (см. << i5 >>).

[[i5]]
. Выбор филиала или тега для импорта
image::images/ss12.png[screenshot,400,align="center"]
{zwsp} +

Домен, импортированный из репозитория GIT, имеет значок GitHub (см. << i2 >>), и будет заблокирован. Рекомендуемый способ обновления кода в таком домене состоит в том, чтобы совершить и протолкнуть обновление в репозитории GIT в качестве нового тега или ветви, а затем обновить домен, используя * Configuration -> Обновить с помощью новой ветви или тега *.

==== Copying Objects Between Domains

Нам часто нужно настраивать код в одном из заблокированных доменов, например, при реализации нашего собственного метода размещения виртуальной реальности. К счастью, мы можем легко скопировать любой объект из заблокированного домена в нашу собственную, используя * Configuration -> Скопировать это ... * (см. << i6 >>).

[[i6]]
. Класс
image::images/ss4.png[screenshot,450,align="center"]
{zwsp} +

Когда мы копируем объект, такой как класс, нас предложены для * от * и * до * доменов. Мы можем при желании отменить решение * копировать по тому же пути * и указать наш собственный путь назначения для объекта (см. << i7 >>).

[[i7]]
. Определение домена и пути назначения
image::images/ss5.png[screenshot,400,align="center"]
{zwsp} +

==== Importing Old Format Exports

Домены были новой функцией автоматического хранилища данных в CloudForms 3.1/Manageiq _anand_. Перед этим выпуском весь код автоматизации, созданный на заводе, содержался в общей структуре, что затрудняло обновления, когда был введен любой код с добавленным пользователем (модификации, поставляемые пользователем, необходимы для экспорта и повторного слияния/слияния всякий раз, когда было выпущено обновление автоматизации).

Чтобы импортировать резервное копирование данных из данных CloudForms 3.0 и предварительного данных Format, мы должны сначала преобразовать его в новый формат данных, например, так:

....
CD/var/www/miq/vmdb
Bin/Rable EVM: Automate: Convert File = Database.xml Domain = Sample \
ZIP_FILE =/tmp/sample_converted.zip
....

=== Namespaces

A _Namespace_-это папка, похожий на папку контейнер для классов, экземпляров и методов, и используется исключительно для организационных целей. Мы создаем пространства имен для логического распоряжения нашего кода, а пространства имен часто содержат другие пространства имен (см. << i8 >>).

[[i8]]
.Namespaces
image::images/ss6.png[screenshot,240,align="center"]
{zwsp} +

=== Classes

_Class_ аналогична шаблону, он содержит общее определение для набора операций автоматизации. У каждого класса есть схема, которая определяет переменные, состояния, отношения или методы, которые будут использовать экземпляры класса.

[NOTE]
Автоматизация данных использует объектно-ориентированную терминологию для этих объектов. _Class_ является общим определением для набора операций автоматизации, и эти классы являются _instantantied_ как конкретные экземпляры.
Классы, с которыми мы работаем в автоматическом хранилище данных, - это не то же самое, что классы Ruby, с которыми мы работаем в наших сценариях автоматизации.

==== Schemas

A _schema_ состоит из ряда элементов, или __fields__, которые описывают свойства класса. Схема часто имеет только одну запись - для запуска одного метода - но во многих случаях у нее есть несколько компонентов. << i9 >> показывает схему для класса _placement_, который имеет несколько различных типов поля.

[[i9]]
. Более сложная схема
image::images/ss7.png[screenshot,380,align="center"]
{zwsp} +

==== Adding or Editing a Schema 

Мы добавляем или редактируем каждое поле схемы в редакторе схемы, указав * тип * из раскрывающегося списка (см. << i10 >>).

[[i10]]
. Шема
image::images/ss8.png[screenshot,500,align="center"]
{zwsp} +

Каждый тип поля имеет связанный * тип данных *, который также выбирается из раскрывающегося списка (см. << i11 >>).

[[i11]]
.
image::images/ss9.png[screenshot,500,align="center"]
{zwsp} +

CloudForms 4.2/Manageiq _euwe_ ввел несколько новых типов данных: _null Coalescing_, _host_, _vm_, _storage_, _EMS_, _policy_, _server_, _request_, _provision_ и _user_. Они будут обсуждаться в более поздней главе.

===== Default Values

Мы можем определить значения по умолчанию для полей в схеме классов. Они будут унаследованы всеми экземплярами, созданными из класса, но могут быть при условии переопределения в схеме любого конкретного экземпляра.

==== Relationships

Одним из типов поля схемы является __relationship__, который связан с другими случаями в других частях автоматического хранилища данных. Мы часто используем отношения как способ вместе цеплять экземпляры, и значения отношений могут принимать переменные замены для гибкости (см. << I12 >>).

[[i12]]
.
image::images/ss10.png[screenshot,450,align="center"]
{zwsp} +

=== Instances

_Instance_ - это конкретный _instantiation_ или «клон» общего класса, и это сущность, управляемая двигателем автоматизации. Экземпляр содержит копию схемы классов, но с фактическими значениями заполненных полей (см. << i13 >>).

[[i13]]
Определение класса.
image::images/ss11.png[screenshot,280,align="center"]
{zwsp} +

=== Methods

_Method_-это автономный блок кода Ruby, который выполняется при выполнении любой операции автоматизации. Типичный метод выглядит так:

[source,ruby]
....
###################################################################
#
# Описание: выберите облачную сеть
# Зона доступности по умолчанию предоставлена ​​OpenStack
#
###################################################################

# Получите переменные
prov = $ evm.root ["miq_provision"]
Image = prov.vm_template
Поднимите «изображение не указано», если Image.nil?

if prov.get_option (: cloud_network) .nil?
cloud_network = prov.eligible_cloud_networks.first
Если Cloud_network
prov.set_cloud_network (cloud_network)
$ evm.log ("info", "image = [#{image.name}] Cloud Network = [#{Cloud_network.name}]")
конец
конец
....

Методы могут иметь одно из трех значений _location_: *inline *, *buldin *или *uri *. На практике большинство методов, которые мы создаем, являются * встроенными * методами, что означает, что они работают как отдельный рубиновый процесс за пределами рельсов.

=== Summary

В этой главе мы узнали о фундаментальных объектах или организационных единицах, с которыми мы работаем в автоматическом хранилище данных: домены, пространства имен, классы, экземпляры и методы.

Теперь мы готовы использовать эту информацию для написания нашего первого сценария автоматизации.

==== Further Reading

https://access.redhat.com/documentation/en-us/red_hat_cloudforms/4.2/html/scripting_actions_in_cloudforms/tscripting actions в Cloudforms]

https://access.redhat.com/solutions/1225313= Cloudforms 3.1 Экспорт автоматических доменов]

https://access.redhat.com/solutions/12253838.

https://access.redhat.com/solutions/1225413= Cloudforms 3.1 Автоматизированное преобразование модели]

