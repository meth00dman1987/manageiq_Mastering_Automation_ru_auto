[[evm-and-the-workspace]]
== $ evm и рабочее пространство

Когда мы пишем сценарии автоматизации, мы получаем доступ к движке автоматизации и ко всем его объектам через одну сноску переменной `$ evm`: [оригинальный продукт Manageiq был назван _Enterprise Virtuization Manager_, часто сокращается до« evm »]. Иногда это называется _Workspace_.

Как обсуждалось в ссылке: ../ peeping_under_the_hood/gupt.asciidoc [Peeping под капюшоном], переменная `$ evm` -объект - это объект _drb :: drbobject_, представляющий подключение к клиенту Druby обратно к движке автоматизации. Объект на стороне Druby Server нашей переменной `$ evm` является экземпляром объекта` miqaeservice`, который содержит более 40 методов. На практике мы обычно используем только несколько из этих методов, чаще всего:

....
$ evm.root
$ evm.object
$ evm.current (это эквивалентно звонке $ evm.object (ноль))
$ evm.parent
$ evm.log
$ evm.vmdb
$ evm.execute
$ evm.instantiate
....

Мы рассмотрим эти методы более подробно в следующих разделах.

=== $evm.log

`$ evm.log` - это простой метод, который мы уже использовали. Он записывает сообщение в _automation.log_ и принимает два аргумента: уровень журнала и текстовую строку для написания. Уровень журнала может быть написан как символ Ruby (например, `: info`,`: warn`) или как текстовая строка (например, «Info», «Warn»).

=== $evm.root

`$ evm.root` - это метод, который возвращает нам корневой объект в рабочем пространстве (среда, переменные, связанные объекты и т. Д.). Это экземпляр, чей призыв привел нас в механизм автоматизации. От `$ evm.root 'мы можем получить доступ к другим объектам модели обслуживания, таким как` $ evm.root [' vm '] `,` $ evm.root [' user '] `или` $ evm.root [' miq_request '] `(реальные доступные объекты зависят от контекста автоматизации, которые мы выполняем).

[[i1]]
. Объектная модель
image::images/object_model.png[Object Model,500,align="center"]
{zwsp} +

`$ evm.root` содержит много полезной информации, которую мы используем программно для установления нашего запущенного контекста - например, чтобы увидеть, были ли мы вызвали вызов API или из кнопки (см. Также Ссылку: ../ Sperial_debugging/gate.asciidoc [Отладка расследования])))

----
$ evm.root ['vmdb_object_type'] = vm (type: string)
...
$ evm.root ['ae_provider_category'] = инфраструктура (тип: строка)
...
$ evm.root.namespace = Manageiq/System (тип: строка)
$ evm.root ['object_name'] = request (type: string)
$ evm.root ['request'] = call_instance (type: string)
$ evm.root ['encement'] = object_walker (type: string)
----

`$ evm.root также содержит любые переменные, которые были определены на нашем въезде в механизм автоматизации, такие как переменные` $ evm.root ['dialog*'] `‘, которые были определены из нашего диалога по обслуживанию.

=== $evm.object, $evm.current and $evm.parent

Как мы видели, «$ evm.root» возвращает нам объект, представляющий экземпляр, который был запущен при введении автоматизации. Во многих случаях есть схемы, которые содержат отношения с другими экземплярами, и, по мере того, как следует каждая отношения, в под вызывающим объектом создается новый дочерний объект для представления призывающего экземпляра. Все эти объекты живут в одном рабочем пространстве, они имеют одинаковую переменную `$ evm`. К счастью, мы можем получить доступ к любому из объектов в этой иерархии родителей-ребенка, используя `$ evm.object`.

Вызов `$ evm.object` без аргументов возвращает в данный момент экземпляр в данный момент/управление. Как сценарии автоматизации, мы можем думать об этом как «наш в настоящее время запущенный код», и мы также можем получить к нему доступ, используя псевдоним `$ evm.current '. Когда мы хотели получить доступ к нашей переменной схемы «Имя пользователя» в ссылке: ../ Использование_SCHEMA_VARIABLE/grab.asciidoc [Использование переменных схемы], мы получили доступ к ней, используя `$ evm.object ['username']`.

Мы можем получить доступ к нашему родительскому объекту (тот, который позвонил нам), используя `$ evm.object (" .. ")` или псевдоним `$ evm.parent`.

[NOTE]
`$ evm.root 'такой же, как` $ evm.object ("/") `

Когда мы запустили наш первый пример сценария, __hello_world__ (из симуляции), мы указали точку входа _/system/process/request_, и наш запрос был на экземпляре, называемом _call_instance_. Мы передали это пространство имен, класс и экземпляр, которые мы хотели, чтобы оно работало (через отношения).

Это привело бы к иерархии объекта (при просмотре из метода _hello_world_) следующим образом:

....
     --- object hierarchy ---
$ evm.root =/Manageiq/System/Process/запрос
$ evm.parent =/manageiq/system/request/call_instance
$ evm.object =/acme/general/methods/hello_world
....

=== $evm.vmdb

`$ evm.vmdb` - это полезный метод, который можно использовать для извлечения любого объекта _service model_ (см. Ссылку: ../ peeping_under_the_hood/gupt.asciidoc [Peeping под капюшоном]). Метод может быть вызван с одним или двумя аргументами.

==== Single Argument Form

При вызове с одним аргументом метод возвращает тип объекта модели общего обслуживания, и мы можем использовать любой из методов Helper Rails (см. Ссылку: ../ peeping_under_the_hood/gupt.asciidoc [Peeping под капюшоном]) для поиска по имени столбец базы данных:

[source,ruby]
----
vm = $ evm.vmdb ('vm'). find_by_name ('websrv031')
vm = $ evm.vmdb ('vm'). где (: name => 'websrv031')
$ evm.vmdb (: emscluster)
----

Мы также можем использовать более расширенный синтаксис запросов для возврата результатов на основе множества условий, например:

[source,ruby]
----
$ evm.vmdb (: cloudtenant). Где (["ems_id =? и name =?", 2, "admin '])
----

Имя объекта модели службы может быть указано в Camelcase (например, «доступность») или Snake_case (например, «доступность_зоне»), и может быть строкой или символом.

==== Two-Argument Form

Если мы хотим найти объект по его идентификатору, мы можем использовать двух аргументов формы вызова. При вызове с двумя аргументами, вторым аргументом должен быть идентификатор модели службы для поиска, например, так:

[source,ruby]
----
Владелец = $ evm.vmdb ('user', evm_owner_id)
----

Мы должны проявлять осторожность при использовании формы с двумя аргументом. Если нет модели обслуживания, соответствующей указанному идентификатору, метод поднимет исключение `miqaeexception :: serviceNotFound`, а не вернуть` nil '. Мы можем защитить от этого, сами поймав исключение следующим образом:

[source,ruby]
----
Владелец = $ evm.vmdb ('user', evm_owner_id) Rescue Nil
----

'''
.Vm или шаблон?
****
* Вопрос:* Когда мы должны использовать «vm» (`: vm`) или 'vm_or_template' (`: vmortemplate`) в наших поисках `$ evm.vmdb`?

* Ответ:* Поиск объекта 'vm_or_template' (`miqaeservicevmortemplate`) вернет оба виртуальные машины _and_, которые удовлетворяют критериям поиска, тогда как поиск виртуальных оборудования (` `miqaeservicevm`) вернет виртуальные машины. Подумайте о том, нужно ли вам оба возвращены.

Есть некоторые тонкие различия между объектами. `Miqaeservicevm` - это подкласс` miqaeservicevmortemplate`, который добавляет 2 дополнительных метода, которые не имеют отношения к шаблонам: `add_to_service` и` remove_from_service`.

Оба `miqaeservicevmortemplate` и` miqaeservicevm` имеют логический атрибут `template`, который _true_ для изображения или шаблона, и _false_ для виртуальной машины.
****
'''

=== $evm.execute

Мы можем использовать `$ evm.execute`, чтобы назвать один из 13 разных, но полезных методов. Методы определены в сервисной модели под названием _methods_ (`miqaeservicemethods`) и следующие:

* `send_email (до, субъект, тело, content_type = nil)`
* `snmp_trap_v1 (входы)`
* `snmp_trap_v2 (входы)`
* `Category_exists? (Категория)`
* `category_create (options = {})`
* `tag_exists? (Категория, запись)`
* `tag_create (категория, options = {})`
* `service_now_eccq_insert (сервер, имя пользователя, пароль, агент, очередь, тема, имя, источник, * params)`
* `service_now_task_get_records (сервер, имя пользователя, пароль, * params)`
* `service_now_task_update (сервер, имя пользователя, пароль, * params)`
* `service_now_task_service (служба, сервер, имя пользователя, пароль, * params)`
* `create_provision_request (* args)`
* `create_automation_request (options, userid =" admin ", auto_approve = false)`


==== Examples

Мы можем увидеть некоторые примеры вызова этих методов.

===== Creating a tag if one doesn't already exist

[source,ruby]
----
Если $ evm.execute ('tag_exists?', 'stod_centre', '3376')
$ evm.execute ('tag_create', "stod_centre",: name => '3376',
: description => '3376')
конец
----

В этом примере мы называем метод `tag_exists? Если это не так (т.е. `tag_exists?` Возвращает `false`), то мы называем метод` tag_create` для создания тега, передавая аргументы категории тегов, `: name` и`: description`.

===== Sending an Email

[source,ruby]
----
to = 'pemcg@redhat.com'
от = 'miq01@uk.bit63.com'
toot = 'test message'
Body = 'Какой удивительный продукт по управлению облаком!
$ evm.execute ('send_email', от, от, субъект, тело)
----

Здесь мы определяем аргументы «to», «from», «subject» и «body» и называем метод «send_email».

===== Creating a new automation request

Метод `create_automation_request` новый с Manageiq _capablanca_, и он позволяет нам вместе выполнять запросы на автоматизацию цепи. Это также очень полезно, когда мы хотим явно запустить задачу автоматизации в другой зоне, чем в той, в которой находится наш в настоящее время работает сценарий.

[source,ruby]
----
Options = {}
Options [: namespace] = 'вещи'
Options [: class_name] = 'Методы'
Options [: exance_name] = 'myinstance'
Options [: user_id] = $ evm.vmdb (: user) .find_by_userid ('pemcg'). Id
# параметры [: attrs] = attrs
# параметры [: miq_zone] = зона
auto_approve = true

$ evm.execute ('create_automation_request', Options, 'admin', auto_approve)
----

В этом примере мы определяем имена пространства имен, класса и экземпляров, которые будут использоваться для запроса автоматизации, и мы ищем объект модели службы пользователя, которого мы хотим запустить задачу автоматизации AS. Пользователь «администратора» в списке аргументов - это _Requester_, который будет использоваться в целях утверждения.

=== $evm.instantiate

Мы можем использовать `$ evm.Instantiate`, чтобы запустить еще один экземпляр автоматизации программно из метода работы, указав его URI в пространстве автоматизации имен, например,

[source,ruby]
----
$ evm.instantiate ('/discovery/objectwalker/object_walker')
----

Экземпляры, вызванные таким образом, выполняют синхронно, поэтому вызовный метод ожидает завершения, прежде чем продолжить. Призывающий экземпляр также появляется как дочерний объект вызывающего абонента (он видит вызывающего абонента как его `$ evm.parent`).

=== Summary

Это была более теоретическая глава, изучающая восемь наиболее часто используемые методы `$ evm. Footnote: [Существует еще три метода, специфичные для состояния Machine $ evm, которые мы часто используем, но мы рассмотрим тех, кто в ссылке: ../ state_machines/gace.asciidoc [государственные машины]] в наших простых сценариях мы уже использовали три из них; `$ evm.log`,` $ evm.object` и `$ evm.root '. В нашем следующем примере в ссылке: ../ inecilection_anti_affinity_rules/gupt.asciidoc [обеспечение соблюдения правил анти-аффиности] использует два других, и мы будем использовать оставшиеся три по мере продвижения через книгу. Эти методы составляют основную часть нашего сценариста, их использование станет второй природой, поскольку мы продвигаем наши навыки автоматизации.

==== Further Reading

https://github.com/manageiq/manageiq/blob/capablanca/lib/miq_automation_engine/engine/miq_ae_service.rb= miqaeservice]
