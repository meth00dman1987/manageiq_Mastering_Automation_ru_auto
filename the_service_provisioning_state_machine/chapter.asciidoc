[[the-service-provisioning-state-machine]]
== Государственная машина предоставления услуг

Как и следовало ожидать, как CloudForms, так и Manageiq используют государственную машину для разумного обработки рабочего процесса для предоставления услуги. Хотя мы редко модифицируем _service provision state machine_, полезно иметь понимание его шагов и функций, которые он выполняет. В этой более теоретической главе рассматриваются государственная машина и обсуждает его роль в прохождении в рабочем процессе обеспечения значений диалога услуг, которые пользователь имеет ввод.

=== Class and Instances

Машина состояния обслуживания услуг (_serviceprovision_template_ class) управляет последовательности шагов, связанных с предоставлением услуги. Домен _manageiq_ содержит четыре экземпляра этой машины состояния (см. << i1 >>).

[[i1]]
.ServiceProvision_template, экземпляры и метод
image::images/ss1.png[Screenshot,350,align="center"]
{zwsp} +

Схема класса _serviceprovision_template_ содержит ряд состояний. << i2 >> показывает экземпляр _default_ этой машины состояния:

[[i2]]
.Fields of ServiceProvision_Template Class
image::images/ss2.png[Screenshot,550,align="center"]
{zwsp} +

Как мы видим, большинство полей - это * Pre * и * Post * Placeholders вокруг основного * и * CheckProvisioned * состояния, чтобы разрешить дополнительную обработку, если это необходимо. Состояние * configureChildDialog * может использоваться для заполнения параметров `: dialog]` хэш в задаче ребенка, если это необходимо.

=== Passing Service Dialog Options to the Child and Grandchild Tasks

Одна из наиболее сложных задач, которые должны быть достигнуты каким -либо состоянием в статоде услуг, - это передача значений, полученных из диалогового окна обслуживания (если он есть) в фактические задачи, выполняющие обеспечение виртуальной машины (ы). Сложность возникает из трех поколений объекта задачи, участвующего в создании услуги, ресурсов услуг и фактических виртуальных машин (см. << i3 >>).

[[i3]]
.Task Объектная иерархия
image::images/task_hierarchy.png[Screenshot,600,align="center"]
{zwsp} +

Эта иерархия объекта представлена ​​на самом высоком уровне задачей по обеспечению шаблона услуг. Мы получаем доступ к этому:

[source,ruby]
....
$ evm.root ['service_template_provision_task']
....

У Service_template_provision_task есть ассоциация, `miq_request_tasks`, содержащий объекты _miq_request_task_, представляющие создание ресурса (S) _service _. Это предметы или ресурсы, составляющие запрос на обслуживание (даже один элемент каталога услуг рассматривается как пакет, содержащий один ресурс услуг).

Каждый _Child_ (ресурс службы) MIQ_REQUEST_TASK также имеет ассоциацию `MIQ_REQUEST_TASKS`, содержащая задачи предоставления виртуальной машины, связанные с созданием фактических виртуальных машин для сервисного ресурса. Это _miq_request_task_ является специфичным для поставщика.

Именно на втором уровне miq_request_task (также известный как _grandchild task_) мы должны передать значения диалога службы, которые влияют на обеспечение виртуальной машины (например, `: vm_memory` или`: vm_target_name`).

(Ссылка: ../ service_objects/gupt.asciidoc [Объекты службы] обсуждает структуру объекта службы более подробно)

=== Accessing the Service Dialog Options

Если диалоговое окно обслуживания использовалось при создании запроса автоматизации (либо из кнопки, либо из службы), то в диалоговом окне «Сервис» добавляются пара клавиш/значение из диалога службы и последующих объектов задачи. Они доступны в двух местах; в качестве отдельных ключей, доступных из `$ evm.root`, и из параметров объекта задачи хеша в качестве ключа`: dialog '.

[source,ruby]
----
$ evm.root ['service_template_provision_task']. Options [: dialog] = \
           {
"Dialog_option_0_service_name" => "Новый сервер",
"Dialog_option_0_service_description" => "Мой новый сервер",
"DILAOG_OPTION_0_VM_NAME" => "RHEL7SRV023",
"Dialog_tag_0_Department" => "Инжиниринг",
"запрос" => "clone_to_service"
           }
----

или

[source,ruby]
----
$ evm.root ['dialog_option_0_service_description'] = мой новый сервер
$ evm.root ['dialog_option_0_service_name'] = новый сервер
$ evm.root ['dialog_option_0_vm_name'] = rhel7srv023
$ evm.root ['dialog_tag_0_department'] = инженерия
----

Доступ к параметрам диалога из `wortions [: dialog]` проще, когда мы не обязательно знаем имя опции.

==== ConfigureChildDialog

Когда у нас есть несколько поколений объекта задачи дочерней задачи (как и при обеспечении виртуальных машин из службы), нам также необходимо передавать параметры диалога из родительского объекта (задача по обеспечению шаблона обслуживания), в различные дочерние объекты, в противном случае они не будут видны детям.

Обычно это делается в состоянии * configureChildDialog * State Machine. В экземпляре _default_ _ServiceProvision_template_ Matcher это состояние не используется, но мы можем добавить наш собственный экземпляр/метод, если мы хотим использовать эту функциональность.

Если мы решим добавить наш собственный метод на этом этапе, мы можем вставить пары клавиш/значение из диалога службы в параметры `: dialog]` hash объекта задачи дочерней задачи с использованием метода `set_dialog_option`.

Например:

[source,ruby]
----
stp_task = $ evm.root ["service_template_provision_task"]
vm_size = $ evm.root ['dialog_vm_size']
STP_TASK.MIQ_REQUEST_TASKS.ERO DO | Child_task |
case vm_size
Когда "маленький"
memory_size = 4096
Когда "большой"
memory_size = 8192
конец
child_task.set_dialog_option ('dialog_memory', memory_size)
конец
----

Это позволяет рабочим процессам предоставления виртуальной машины для дочерних и внуков (которые проходят через стандартную статускую машину VM, который мы уже изучили) для доступа к своему собственному объекту задачи `Options [: dialog]` hash и установить соответствующие параметры предоставления.

=== VM Naming for Services

Хотя это и не сразу очевидно, машина государства предоставления услуг работает в контексте _TASK_, поэтому любая обработка профиля контрольной группы управления доступом, включая именование и одобрение, уже произошла к тому времени, когда выполняется любой из наших методов штата (у нас есть $ evm.roo ['service_template_provision_task'] `$ a evm.root ['service_template_provision_task']` $ evm.root ['service_template_provision_task'].

Поскольку мы работаем в контексте задачи процесса обеспечения, входные переменные в процесс именования - `: vm_name`,`: vm_prefix` и т. Д. Процесс именования уже запускается; Они не будут ссылаться снова.

Однако мы можем напрямую обновить значения `: vm_target_name` и`: vm_target_hostname` в параметрах объекта задачи в любой момент до того, как * положение * Состояние _vmprovision_vm_ matche, например, так:

[source,ruby]
----
task.set_option (: vm_target_name, "server001")
task.set_option (: vm_target_hostname, "server001")
----

К сожалению, на этом этапе у нас нет возможности добавить в наше виртуальное оборудование синтаксис стиля «$ n {2}», надеясь, что двигатель автоматизации назначит нам следующий уникальный номер. Если бы мы хотели гарантировать уникальность, мы должны были бы использовать что -то вроде следующего кода:

[source,ruby]
----
для я в (1..999)
new_vm_name = "#{vm_prefix}#{function}#{i.to_s.rjust (2," 0 ")}#{суффикс}"
Перерыв, если $ evm.vmdb ('vm_or_template'). find_by_name (new_vm_name) .blank?
конец
----

Этот цикл проходит через все числа от 1 до 999, добавляя каждое число в виде трехзначного суффикса с нулевым прибором к префиксу имени виртуальной машины. Сценарий выполняет поиск модели службы объекта `vm_or_template`, содержащего это комбинацию имени/суффикс, и если виртуальная машина этого имени не существует, цикл выходит с переменной` new_vm_name` соответственно.

=== Summary

Это был краткий обзор государственной машины, предоставляющей услуги, демонстрируя его относительную простоту.

Одна из основных задач государственной машины состоит в том, чтобы перенести значения из диалога услуг в рабочий процесс обеспечения, и мы увидели, как перейти по трем поколениям объекта задачи, участвующего в операции предоставления услуг, чтобы достичь этого. Два необычных экземпляра машины были созданы, чтобы упростить эту задачу для нас, и мы будем изучать их в следующей главе.
