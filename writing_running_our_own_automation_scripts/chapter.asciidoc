[[writing-running-our-own-automation-scripts]]
== Написание и запуск наших собственных сценариев автоматизации

Давайте прыгнем прямо и начнем писать наш первый сценарий автоматизации. В моде, проведенной временем, мы напишем "Привет, мир!" к автоматическому файлу журнала.

Прежде чем мы сделаем все, что нам нужно, чтобы убедиться, что роль сервера * Automation * будет определяться на нашем устройстве Manageiq. Мы делаем это из меню * configure -> configuration *, выбрав сервер Manageiq в аккордеоне _Settings_ (см. << i1 >>).

[TIP]
====
Роль сервера * Automation Engine * теперь включена по умолчанию в CloudForms 4.0 (Manageiq _capablanca_), а затем, но все же стоит проверить, что эта роль установлена ​​на нашем устройстве Manageiq.
====

[[i1]]
. Настройка роли сервера двигателя автоматизации
image::images/ss1.png[Screenshot,330,align="center"]
{zwsp} +

'''
.
****
Установка роли * Automation Engine * необходима для выполнения задач _queud_ Automate (это включает в себя все, что начинается как автоматизация __Request__, который мы рассмотрим позже в ссылке: ../ requests_and_tasks/gupt.asciidoc [запросы и задачи]). Автоматизируют действия, инициированные непосредственно из WebUI, например, запуск экземпляров из моделирования или методы обработки для заполнения динамических диалогов, - выполняются на самом устройстве WebUI, независимо от того, включает ли он роль * Automation Engine *.

Наши первые примеры автоматизации в книге будут запускаться от симуляции, поэтому нам не нужна роль * Automation Engine * для работы. Когда мы переходим к более продвинутым способам запуска наших сценариев, нам понадобится включенная роль, поэтому, проверив, что она установлена ​​сейчас, у нас будет на одну меньшую вещь для устранения неполадок по мере продвижения через книгу.
****
'''

=== Creating the Environment

Прежде чем создать наш первый сценарий автоматизации, нам нужно поставить некоторые вещи на месте. Мы начнем с добавления нового домена под названием _acme_. Мы добавим весь наш код автоматизации в этот новый домен.

==== Adding a New Domain

В Automate Explorer выделите значок * Datastore * и нажмите * Configuration -> добавьте новый домен * (см. << i2 >>).

[[i2]]
. Выдвижение нового домена
image::images/ss2.png[Screenshot,450,align="center"]
{zwsp} +

Мы дадим домену * имя * _ACME_, * Описание * _ACME CORP._ и убедитесь, что выбран флажок * ENADADED *.

==== Adding a Namespace

Теперь мы добавим пространство имен в этот домен, который называется __general__. Выделите значок домена _acme_ в боковой панели и нажмите ** Конфигурация -> Добавить новое пространство имен ** (см. << i3 >>).

[[i3]]
. Расщепление нового пространства имен
image::images/ss3.png[Screenshot,450,align="center"]
{zwsp} +

Дайте пространство имен * имя * _general_ и * описание * _general content_

==== Adding a Class

Теперь мы добавим новый класс, который называется __methods__.

[NOTE]
Может показаться, что называть классовые «методы» несколько сбивает с толку, однако многие из общих классов в домене _manageiq_ в автоматическом хранилище данных называются «методами», чтобы обозначить их общий характер).

Выделите значок домена _general_ в боковой панели и нажмите * Configuration -> добавить новый класс * (см. << i4 >>).

[[i4]]
.Dling новый класс
image::images/ss4.png[Screenshot,450,align="center"]
{zwsp} +

Дайте классу имя * name * _methods_ и * Описание * _general экземпляры и методы_. Мы оставим имя * отображения * пустым для этого примера.

==== Editing the Schema

Мы создадим простую схему. Нажмите на вкладку*Schema*для класса _methods_ и нажмите ** Конфигурация -> редактировать выбранную схему ** (см. << i5 >>).

[[i5]]
. Редактирование схемы
image::images/ss5.png[Screenshot,600,align="center"]
{zwsp} +

Нажмите ** Новое поле **, и добавьте одно поле с именем __execute__,*type*_method_ и*type*__string__ (см. << i6 >>).

[[i6]]
. Выдвигая новую схему поля
image::images/ss6.png[Screenshot,550,align="center"]
{zwsp} +

Нажмите значок * Tick * в столбце Lefthand, чтобы сохранить запись в поле, и нажмите кнопку * Сохранить *, чтобы сохранить схему. Теперь у нас есть наше общее определение класса, называемое _methods_ setup, с простой схемой, которая выполняет один метод.

=== Hello, World!

Наш первый метод автоматизации очень прост, мы напишем запись в файл _automation.log_ с использованием двухстрочного скрипта:

[source,ruby]
----
$ evm.log (: Информация, "Привет, мир!")
Выход miq_ok
----

==== Adding a New Instance

Как упоминалось в ссылке: ../ ВВЕДЕНИЕ_TO_THE_AUTOMATE_DATASTORE/gupt.asciidoc [Введение в автоматизация данных данных] Двигатель автоматизации запускает сценарии в контексте _instances_, так что сначала нам нужно создать экземпляр из нашего класса. В Tab*Actestance*Нового*Methods*Class, выберите ** Конфигурация -> Добавить новый экземпляр ** (см. << i8 >>).

[[i8]]
. Добавление нового экземпляра в наш класс
image::images/ss8.png[Screenshot,500,align="center"]
{zwsp} +

Мы позвоним в экземпляр __hello_world__, и он запустит (выполнить) метод под названием __hello_world__ (см. << i9 >>).

[[i9]]
. Введение деталей экземпляра
image::images/ss9.png[Screenshot,430,align="center"]
{zwsp} +

Нажмите кнопку «Добавить *».

==== Adding a New Method

В вкладке «Методы»*Нового класса _methods_, выберите ** Конфигурация -> Добавить новый метод ** (см. << i10 >>).

[[i10]]
. Добавление нового метода в наш класс
image::images/ss10.png[Screenshot,500,align="center"]
{zwsp} +

Назовите метод _Hello_world_ и вставьте две наши строки кода в окно * Data * (см. << i11 >>).

[[i11]]
. ВОПРОС
image::images/ss11.png[Screenshot,430,align="center"]
{zwsp} +

Нажмите *Validate *, а затем кнопку *Добавить *.

[TIP]
Получите привычку использовать кнопку «Validate *», она может сэкономить много времени, поймать рубиновые синтаксические опечатки, когда вы разрабатываете более сложные сценарии

=== Running the Instance

Мы запустим наш новый экземпляр, используя функциональность _Simulation_ Automate, но прежде чем мы сделаем это, войдите в CloudForms/Manageiq снова из другого браузера или вкладки частного просмотра и перейдите к * Automate -> Log * в сноске WebUI: [Альтернативно SSH в Appliance As _ROOT_ и `war/www/miq/vmation withogt_ и var/miq/vmation.

[NOTE]
CloudForms/Manageiq Webui использует файлы cookie сеанса браузера, поэтому, если мы хотим два или более одновременных сеансов входа в систему (особенно в качестве разных пользователей), он помогает использовать различные веб -браузеры или частные/окна инкогнито.

В симуляции мы фактически запускаем экземпляр с именем _call_instance_ в _/system/request/_ _ -имен -пространство домена _manageiq_, и это, в свою очередь, называет наш экземпляр _hello_world_ с использованием пары _namespace_, _class_ и _instance_ Ссылка: ../ ways_of_entering_automate/gupt.asciidoc [способы ввода автоматизации]).

В меню * Automate -> Simulation * заполните детали (см. << i12 >>).

[[i12]]
.
image::images/ss12.png[Screenshot,480,align="center"]
{zwsp} +

Нажмите *отправить *

Если все прошло хорошо, мы должны увидеть нашу "Привет, мир!" Сообщение отображается в файле _automation.log_.

....
Вызов [inline] Method [/acme/general/methods/hello_world] с входами [{}]
<Aemethod [/acme/general/methods/hello_world]> Запуск
<Aemethod hello_world> Привет, мир!
<Aemethod [/acme/general/methods/hello_world]> окончание
Метод выходит с RC = MIQ_OK
....

Успех!

=== Exit Status Codes

В нашем примере мы использовали код состояния выхода MIQ_OK. Хотя с такими простыми методами нам не нужно строго указывать код выхода, это хорошая практика. Когда мы строим более продвинутые мультиметодные классы и государственные машины, код выхода может сигнализировать о состоянии ошибки в механизм автоматизации, чтобы можно было предпринять действие.

Есть четыре кода выхода, которые мы можем использовать:

* Miq_ok* (0) - продолжает нормальную обработку. Это зарегистрировано в _automation.log_ как:

....
Метод выходит с RC = MIQ_OK
....

* Miq_warn* (4) - Предупреждающее сообщение, продолжает обработку. Это зарегистрировано в _automation.log_ как:

....
Метод выходит с RC = MIQ_WARN
....

* MIQ_ERROR / MIQ_STOP* (8) - ОСТАНОВИТЬ ОБРАЗОВАНИЕ Текущий объект. Это зарегистрировано в _automation.log_ как:

....
Остановка экземпляра, потому что [метод выходит с RC = MIQ_STOP]
....

* Miq_abort* (16) - прерывает целое экземпляр автоматизации. Это зарегистрировано в _automation.log_ как:

....
Прерывание экземпляров, потому что [метод выходит с RC = MIQ_ABORT]
....

[NOTE]
====

Разница между miq_stop и miq_abort является тонкой, но вступает в игру, когда мы разрабатываем более продвинутые автоматические рабочие процессы.

MIQ_STOP останавливает действующий экземпляр в данный момент, но если этот экземпляр был вызван с помощью ссылки из другого экземпляра «родитель», последующие шаги в родительском экземпляре все равно будут завершены.

MIQ_ABORT останавливает в настоящее время действующий экземпляр и любой родительский экземпляр, который его вызвал, полностью завершая задачу автоматизации.
====

=== Summary

В этой главе мы видели, как просто создать наш собственный домен, пространство имен, класс, экземпляр и метод, и запустить наш сценарий из симуляции. Это основные методы, которые мы используем для всех наших сценариев автоматизации, и мы широко используем эти знания по мере продвижения через книгу.

Мы также обнаружили коды состояния, которые мы должны использовать для передачи нашего статуса выхода обратно в механизм автоматизации.
