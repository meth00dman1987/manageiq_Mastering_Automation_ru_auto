[[catalogitembundleinitialization]]
== Каталог {item, pundle} инициализация

В ссылке: ../ the_service_provisioning_state_machine/gupt.asciidoc [машина для обеспечения услуг] мы увидели, что два случая стационарных машин, обеспечивающих услуги, называются _catalogiteminitialization_ и _catalogbundleinitialization_. Эти две государственные машины значительно упрощают процесс создания элементов и пакетов сервисных каталогов, построенных в диалогах с богатым обслуживанием, без необходимости каких -либо сценариев рубины.

[NOTE]
Каталог услуг _ITEM_ обычно обеспечивает один тип виртуальной машины (хотя это может привести к тому, что несколько виртуальных машин одного и того же типа будут представлены). Каталог сервисов _bundle_ может предоставить несколько элементов службы за один раз, что позволяет нам развернуть более многочисленные рабочие нагрузки сервера с одного щелчка.

В этой главе мы подробно рассмотрим эти два экземпляра машины. Мы посмотрим, как они позволяют нам назвать элементы нашего диалога сервиса таким образом, чтобы значения автоматически передавались в рабочий процесс, без необходимости дальнейших сценариев автоматизации.

=== CatalogItemInitialization

Мы можем указать машину состояния _catalogiteminitialization_ в качестве точки входа, когда мы создаем элемент каталога услуг.

Государственная машина была записана, чтобы упростить процесс настройки предоставленной виртуальной машины, используя значения, считываемые из диалога службы. Это происходит путем установки вариантов значений хэша или тегов в детском и внуке `miq_request_task` объектов, из специально сконструированных имен элементов диалога службы. Это также позволяет нам указать новое уникальное имя и описание для полученной службы.

Схема для экземпляра _catalogiteminitialization_ показана в << i1 >>.

[[i1]]
. Поля экземпляра машины состояния каталогтиминициализации
image::images/ss1.png[Screenshot,600,align="center"]
{zwsp} +

Мы можем видеть, что схема использует состояние * pre1 * для добавления диалогового аналога (общего между _catalogiteminitialization_ и _catalogbundleinitialization_ State Machines). Он также использует состояние * pre2 * для указания метода _catalogiteminitialization_, который устанавливает соответствующие значения вариантов и тегов вариантов объекта дочернего объекта.

Сам метод _catalogiteminitialization_ зависит от входов диалога, которые были правильно проанализированы с помощью _dialog_parser_, и это требует от нас использования конкретного соглашения об именованиях для элементов нашего диалогового окна.

==== Service Dialog Element Naming Convention

Чтобы правильно выполнить диалог службы -> Options_HASH или заменить тега, мы должны определенно назвать элементы диалога Service.

===== Single options hash key

Самый простой элемент диалога с обслуживанием для обработки - это то, что подсказывает значение для единого клавиша HASH с параметрами. Назовите элемент диалогового срока службы как:

* option_0_key_name_* (для обратной совместимости с Cloudforms 3.1/Manageiq _anand_)

или просто

* _key_name_* (действителен для CloudForms 3.2/Manageiq _botvinnik_ и позже)

Например, мы можем создать элемент диалога службы, как показано в << i2 >>.

[[i2]]
Элемент диалогового окна.
image::images/ss2.png[Screenshot,420,align="center"]
{zwsp} +

Полученное значение значения ввода из этого диалога во время выполнения будет распространяться в варианты вариантов задачи ребенка, как:

[source,ruby]
....
miq_request_task.options [: vm_memory]
....

«0» в имени диалога относится к номеру последовательности элемента при обеспечении. Для диалогового срока службы, выступающего за один каталог _ITEM_ Это всегда будет нулевым. Для диалогового окна службы, выходящего на каталог _bundle_, включающий несколько элементов, номер последовательности показывает, какой из элементов компонента следует передавать параметр диалога (элемент с последовательности имен «0» будет распространяться на все элементы).

Несколько значений * key_name * распознаются и специально связаны с помощью метода _catalogiteminitialization_. Мы можем назвать элемент текстового поля как либо *vm_name *или *vm_target_name *, и полученное входное значение текстовой строки будет распространяться на все:

[source,ruby]
....
miq_request_task.options [: vm_target_name]
miq_request_task.options [: vm_target_hostname]
miq_request_task.options [: vm_name]
miq_request_task.options [: linux_host_name]
....

Если мы назовуте элемент текстового поля как *service_name *, то полученная служба будет названа из текстового значения этого элемента.

Если мы назовуте элемент текстового поля как *service_description *, то полученное описание службы будет обновлено из текстового значения этого элемента.

===== Single tag

Мы также можем создать элемент диалогового окна службы текста, чтобы применить один тег. Формат именования аналогичен формату названия опции, но с использованием префикса «TAG_» и суффикс имени категории тегов.

Например, мы можем запрашивать тег в категории * Департамента *, назвав элемент диалога службы как * TAG_0_Department * (см. << i3 >>).

[[i3]]
Элемент диалогового окна.
image::images/ss3.png[Screenshot,420,align="center"]
{zwsp} +

Ввод значения в элемент диалога службы во время выполнения должен быть тегом в этой категории тегов. Когда элемент этого типа обрабатывается методом _catalogiteminitialization_, если либо категория, либо тег в настоящее время не существует, он будет создан.

=== CatalogBundleInitialization

Установка _catalogbundleinitialization_ должна быть указана при создании каталога услуг _bundle_.

Схема для экземпляра _catalogbundleinitialization_ такая же, как и для _catalogiteminitialization_, за исключением того, что этап * pre2 * вызывает метод _catalogbundleinialization_.

Метод _catalogbundleinitialization_ передает значения элемента диалога службы в метод каждого элемента каталога _catalogiteminitialization_, который все еще требуется для установки вариантов MIQ_REQUEST_TASK HASH для положения этого элемента каталога.

=== Summary

В этой главе были представлены две государственные машины предоставления услуг, которые мы можем использовать для создания элементов и пакетов каталога услуг, без необходимости каких -либо сценариев Ruby. Мы можем создать простые, но впечатляющие каталоги обслуживания за считанные минуты, используя эти точки входа, и мы видим практическое пример этого в ссылке: ../ Creative_a_service_catalog_item/gupt.asciidoc [Создание элемента каталога обслуживания].

==== Further Reading

Стоит ознакомиться с тремя методами, которые выполняют анализ и транспонирование значений диалога. Это диалога, каталогтиминициализация и каталогбундлейнитиолизация.

https://github.com/manageiq/manageiq/blob/capablanca/db/fixtures/ae_datastore/manageiq/service/provisioning/statemachines/methods.class/__methods__/dialog_parser.rbцер -диал.

https://github.com/manageiq/manageiq/blob/capablanca/db/fixtures/ae_datastore/manageiq/service/provisioning/statemachines/methods.class/__methods__/catalogiteminitialization.rb[catalogiteminitiatization] метод] метод] метод] методикэмтинизирующий

https://github.com/manageiq/manageiq/blob/capablanca/db/fixtures/ae_datastore/manageiq/service/provisioning/statemachines/methods.class/__methods__/catalogbundleinitialization.rbrbunlogbunleintialitialitialitialitialitialitialitialitialitialitialitialitialitialitialitialitialiation.

