[[working-with-virtual-machines]]
== Работа с виртуальными машинами

Наши два примера автоматизации были немного абстрактными, но в этой главе мы будем работать с реальной виртуальной машиной. Наш сценарий найдет и использует объект двигателя автоматизации, представляющий виртуальную машину, и мы будем называть один из методов объекта. Вместо того, чтобы запустить наш сценарий из симуляции, как у нас до сих пор, мы настроим дисплей WebUI для нашей виртуальной машины и добавим новую кнопку панели инструментов для запуска нашего скрипта.

=== Custom Attributes

CloudForms/Manageiq естественным образом собирает большое количество данных о каждой виртуальной машине или экземпляре, которые он управляет, и отображает это в веб -сайте. Например, мы можем изучить такие атрибуты, как IP -адрес, операционная система, количество процессоров или конфигурацию диска, но иногда полезно добавлять свои собственные комментарии или примечания к виртуальной машине. CloudForms/Manageiq позволяет нам делать это в форме _custom attributes_, которые имеют две части: имя (иногда называемое _key_) и значение текстовой строки (см. << i17 >>).

[[i17]]
. Пример пользовательских атрибутов
image::images/ss17.png[Screenshot,500,align="center"]
{zwsp} +

[TIP]
Пользовательские атрибуты-это полезный способ хранить любую связанную информацию о свободном тексту с объектом, особенно виртуальная машина. Мы могли бы сохранить, например, идентификатор элемента конфигурации CMDB, или, возможно, какой -то текст, описывающий состояние конфигурации. Пользовательские атрибуты виртуальной машины видны в WebUI и читаются из сценария автоматизации.

В этом примере мы создадим метод автоматизации, который добавляет пользовательский атрибут к виртуальной машине. Атрибут будет виден любому пользователю, который нажимает подробности виртуальной машины в веб -сайте.

Мы запустим экземпляр Automate с пользовательской кнопки, которую мы добавим на панель инструментов в веб -кадре Virtual Machine, и мы включим диалог, чтобы запросить текст, чтобы добавить в пользовательский атрибут.

=== Creating the Service Dialog

Первое, что мы должны сделать, это создать _service Dialog_, который будет отображаться при нажатии нашей пользовательской кнопки. Создание диалога службы-это многоэтапный процесс, включающий добавление вкладок, поля и элементов диалога, таких как текстовые поля, радиопроизводительные кнопки или раскрывающиеся списки.

Перейдите к ** Automate -> Настройка **, выберите*Диалог службы*в аккордеоне. Выделите __all Dialogs__, затем выберите * configuration -> добавить новый диалог * (еще не нажмите кнопку «Добавить *») (см. << i1 >>).

[[i1]]
. Выдвижение нового диалога услуг
image::images/ss1.png[Screenshot,450,align="center"]
{zwsp} +

Введите _button_ для информации о диалоге *label *и *description *, выберите «Отправить» *и *Отмена *и нажмите *+ Добавить новую вкладку в этот диалог *(не нажмите кнопку «Добавить *» еще) (см. << i2 >>).

[[i2]]
. Добавление новой вкладки в диалог
image::images/ss2.png[Screenshot,450,align="center"]
{zwsp} +

Введите _main_ для информации о вкладке *label *и *description *и нажмите *+ Добавьте новое поле на эту вкладку *(не нажмите кнопку «Добавить *» еще). Обратите внимание, как форма диалогового окна динамически строится на панели Lefthand _accordion_ (см. << i3 >>).

[[i3]]
. Добавление нового поле на вкладку
image::images/ss3.png[Screenshot,450,align="center"]
{zwsp} +

Введите _custom attribute_ для информации о поле *label *и *description *и нажмите *+ добавить новый элемент в этот поле *(не нажмите кнопку «Добавить *» еще). Диалог продолжает обретать форму в аккордеоне (см. << i4 >>).

[[i4]]
. Выдвигая новый элемент в коробку
image::images/ss4.png[Screenshot,450,align="center"]
{zwsp} +

Мы дадим первым элементом * метку * _key_, * имя * of _key_ и a * type * of _text box_. Оставьте другие значения по умолчанию (еще не нажимайте кнопку * Добавить *). Атрибут * ключа * появляется в аккордеоне, как только мы добавим имя элемента (см. << i5 >>).

[[i5]]
. Включение информации о элементе
image::images/ss5.png[Screenshot,500,align="center"]
{zwsp} +

Нажмите *+ Добавить новый элемент в этот поле *, чтобы создать второй элемент. Мы дадим второму элементу * метку * _value_, * имя * of _value_ и a * type * of _text box_. Оставьте другие значения по умолчанию, и теперь, наконец, нажмите кнопку * Добавить *. Завершенное диалоговое окно сохраняется и отображается (см. << i16 >>).

[[i16]]
. Завершенный диалог
image::images/ss16.png[Screenshot,350,align="center"]
{zwsp} +

=== Creating the Instance and Method

Мы создаем новый экземпляр в нашем классе _methods_ так же, как и раньше, называется __add_custom_attribute__. Мы оставляем ** пароль **,*ServerName*и*Имя пользователя*Поля схемы, но добавляем значение _ADD_Custom_attribute_ в поле*Execute*.

[TIP]
Как мы видим здесь, определение атрибутов в нашей схеме классов не означает, что мы должны использовать их в каждом случае, созданном из класса. Мы можем создать общие схемы класса, которые содержат ряд атрибутов, которые могут потребоваться экземпляры.

==== The Code

Значения, введенные в диалоговое окно, доступны для нашего метода через `$ evm.root. Двигатель автоматизации префиксирует имена элементов диалога с помощью «dialog_», поэтому значения, которые мы хотим прочитать, - это `$ evm.root ['dialog_key']` и `$ evm.root ['dialog_value']`.

Наш код для этого примера будет следующим:

[source,ruby]
----
$ evm.log (: info "add_custom_attribute начал")
#
# Получить объект виртуальной машины
#
vm = $ evm.root ['vm']
#
# Получите значения диалога
#
key = $ evm.root ['dialog_key']
значение = $ evm.root ['dialog_value']
#
# Установите пользовательский атрибут
#
vm.custom_set (ключ, значение)
Выход miq_ok
----

Мы создаем новый метод в нашем классе _methods_, как мы делали раньше, и называем его __add_custom_attribute__. Вставляем код в поле *Data *, нажимаем *Validate *, затем *добавить *.

==== Create the /System Entry Point

Чтобы проиллюстрировать альтернативный способ вызвать экземпляр, мы собираемся создать нашу собственную точку входа непосредственно в _/system/_ -namespace, а не перенаправление через __CALL_INSTANCE__, как и ранее сново: [большинство операций автоматизации Введите автомат данных на _/system/request_. _Call_instance_ уже существует как экземпляр «удобство», который мы можем позвонить с аргументами, чтобы перенаправить прямо в наш собственный экземпляр, поэтому мы использовали это до сих пор. Однако бывают случаи, когда нам нужно напрямую создать нашу собственную точку входа в _/system/request_, поэтому этот пример показывает, как мы это делаем.].

Сначала мы должны скопировать класс _manageiq/system/request_ в наш собственный домен (см. << i7 >>).

[[i7]]
.Copying класс /системы /запроса
image::images/ss7.png[Screenshot,450,align="center"]
{zwsp} +

Скопируйте класс в домен _ACME_ и убедитесь, что * копировать в тот же путь *.

Теперь мы должны создать новый экземпляр класса (см. << i8 >>).

[[i8]]
. Добавление нового экземпляра в класс скопированной /системы /запроса
image::images/ss8.png[Screenshot,450,align="center"]
{zwsp} +

Дайте новому экземпляру имя __add_custom_attribute__. Введите __/general/methods/add_custom_attribute__ в поле * rel1 * (см. << i9 >>).

[[i9]]
.Ssiting новое имя экземпляра и поле Rel1
image::images/ss9.png[Screenshot,350,align="center"]
{zwsp} +

=== Running Automation Scripts from a Button

CloudForms/Manageiq позволяет нам расширять функциональность WebUI, добавляя наши собственные кнопки в выбранные типы объектов в пользовательском интерфейсе. Вместо того, чтобы использовать функцию моделирования Automate, как мы делали раньше, мы собираемся запустить этот сценарий автоматизации с пользовательской кнопки, которую мы добавим в объект отображения виртуальной машины.

==== Creating the Button Group

Кнопки всегда отображаются из раскрывающегося списка _button Group_, поэтому сначала мы должны создать новую группу кнопок.

Перейдите к ** Automate -> Настройка ** и выберите*кнопки*в аккордеоне. Теперь выделите ** Типы объектов -> VM и экземпляр **, затем выберите ** Configuration -> Добавить новую группу кнопок ** (см. << i10 >>).

[[i10]]
.Dling новая группа кнопок
image::images/ss10.png[Screenshot,480,align="center"]
{zwsp} +

Установите текст группы кнопок * и * кнопки «Паратью». Выберите подходящее изображение группы кнопок * из доступного раскрывающегося списка и нажмите кнопку «Добавить *», чтобы создать группу кнопок.

==== Creating the Button

Теперь, когда у нас есть наша группа кнопок, мы можем добавить кнопку к ней, чтобы вызвать наш сценарий.

Выделите новую группу кнопок _vm Operations_ в аккордеоне и выберите ** Конфигурация -> Добавьте новую кнопку ** (см. << i11 >>).

[[i11]]
. Добавление новой кнопки в группу кнопок
image::images/ss11.png[Screenshot,430,align="center"]
{zwsp} +

Установите кнопку «Текст» * и * кнопку «Текст» * на _add пользовательский атрибут_. Выберите подходящее * кнопочное изображение * из доступного раскрывающегося списка и выберите наш новый диалог _button_ в раскрывающемся списке * Dialog *. В разделе * Объекта * Мы указам новый экземпляр __add_custom_attribute__, который мы создали в _/system/request_ (см. << i12 >>).

[[i12]]
.
image::images/ss12.png[Screenshot,550,align="center"]
{zwsp} +

==== Running the Instance

Если мы перейдем к виртуальной машине в WebUI и рассмотрим ее детали, мы должны увидеть нашу новую группу кнопок _VM Operations_, отображаемая на панели инструментов. Если мы нажмите значок группы кнопок, мы должны увидеть кнопку, отображаемую как раскрывающуюся спину (см. << i13 >>).

[[i13]]
. Новая группа кнопок и кнопку добавлены на панель инструментов
image::images/ss13.png[Screenshot,450,align="center"]
{zwsp} +

Если мы нажмеем кнопку «Добавить пользовательский атрибут» *, мы должны быть представлены с нашим диалогом (см. << i14 >>).

[[i14]]
.
image::images/ss14.png[Screenshot,430,align="center"]
{zwsp} +

Введите немного текста, нажмите ** Отправить ** и подождите несколько секунд. Мы должны увидеть новый пользовательский атрибут, отображаемый на панели с деталями виртуальной машины (см. << i15 >>).

[[i15]]
. Недавно добавленный пользовательский атрибут
image::images/ss15.png[Screenshot,450,align="center"]
{zwsp} +

=== Summary

В этой главе мы узнали несколько новых полезных навыков. В нашем сценарии автоматизации мы видели, как работать с объектом двигателя автоматизации, представляющим виртуальную машину. Мы расширили функциональность WebUI, создав пользовательскую кнопку, и мы добавили диалог службы, чтобы предложить нашему пользователю для ввода. В довершение всего мы обнаружили утилиту пользовательских атрибутов. Хорошая работа!

Это было полезное введение в автоматизацию «реального мира». Таким образом, добавление пользовательской кнопки для запуска короткого сценария автоматизации довольно распространено в производственных средах. Обычно мы использовали пользовательскую кнопку, чтобы запустить резервную копию виртуальной машины, добавить диск, перенастроить количество процессоров или, например, расширить память.

Мы можем добавить кнопки на панели инструментов отображения Webui для кластеров, данных, хостов и поставщиков, но мы чаще всего добавляем их в виртуальные машины, как мы имеем в этой главе, и услуги (которые мы освещаем в части III).

==== Further Reading

https://access.redhat.com/articles/311753*: Использование пользовательских атрибутов]
