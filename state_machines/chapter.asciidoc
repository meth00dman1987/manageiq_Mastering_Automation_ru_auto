[[state-machines]]
== Государственные машины

Мы упоминали _workflows_ несколько раз в предыдущих главах. Рабочий процесс может быть просто определен как последовательность операций или шагов, которые составляют рабочую процесс. Многие задачи, которые мы выполняем в качестве облачных или системных администраторов, можно разбить на простые шаги рабочего процесса:

Полем Сделай что -нибудь
Полем Сделай что -нибудь
Полем Сделай что -нибудь


Manageiq Automate позволяет нам добавлять интеллект к нашим шагам рабочего процесса, определяя шаги как _states_. Каждое состояние способно выполнять предварительную обработку вокруг основной задачи и может обрабатывать и потенциально восстанавливаться после ошибок, которые возникают при выполнении задачи. Отдельные штаты могут войти в петлю повторного повторения, с максимальным количеством повторных рисков и общим тайм -аутом для определения государства.

[width="86%",cols="^10%,^22%,^22%,^22%,^22%",options="header",align="center"]
|=======
| Шаг | При входе | задача | на выходе | на ошибке
| 1 | Предварительный процесс, прежде чем что-то сделать | Сделайте что-нибудь | Пост-обработка после того, как что-то сделало | обрабатывать любые ошибки, делая что-то
| 2 | Предварительный процесс, прежде чем что-то делать | Сделай что-нибудь | Постопроцесс после того, как что-то делал | обращаться с любыми ошибками, делая что-то
| 3 | Предварительный процесс, прежде чем что-то делать | Сделай что-нибудь | Постопроцесс после того, как что-то делал | обращаться с любыми ошибками, делая что-то
|=======

Когда мы собираем несколько из этих интеллектуальных состояний вместе, это становится автоматическим _state machine_. Логический поток через автоматизированную машину показан в << i0 >>.

[[i0]]
. Specple Automate State Machine Workflow
image::images/state_machine_logic.png[screenshot,650,align="center"]
{zwsp} +

=== Building a State Machine

Мы строим автомат штата так же, как мы определяем любую другую схему классов. Одним из типов поля схемы является *состояние *, и если мы построим определение схемы классов, включающее последовательности *состояний *, это становится машиной состояния.

[TIP]
====
Схема штата машина должна включать в себя _only_ утверждения, атрибуты или состояния. У нас не должно быть никаких линий схемы, которые имеют * тип * поля * отношений * в государственной машине.
====

==== State Machine Schema Field Columns

Если мы посмотрим на все атрибуты, которые мы можем добавить для поля схемы, в дополнение к знаменитому ** имени **, ** Описание ** и*Значение*заголовки, мы видим несколько заголовков столбцов, которые мы до сих пор не использовали (см. << i1 >>).

[[i1]]
.
image::images/ss1.png[screenshot,700,align="center"]
{zwsp} +

Столбки схемы для государственной машины такие же, как и в любой другой схеме классов, но мы используем больше из них.

===== Value (Instance)/Default Value (Schema)

Как и в любой другой схеме классов, это отношение к экземпляру или методу, которое будет выполнено для выполнения основной обработки состояния. Мы можем либо указать полный URI в экземпляр, либо из CloudForms 4.1/Manageiq _Darga_ и дальше, если метод определяется локально в том же классе машины состояния, мы можем ссылаться на него, предшествовав имени метода с помощью «Method ::» (см. << i2 >>)

[[i2]]
. Определяющий поля значения в качестве экземпляра URI или локально определенный метод
image::images/ss5.png[Screenshot,550,align="center"]
{zwsp} +

Удивительно, как это может показаться, нам не обязательно нужно заполнить поле «Значения» для состояния машины (см. *На входе *, далее), хотя это хорошая практика.

===== On Entry

При желании мы можем определить * на входе * _method_ запустить перед запуском метода «Main» (value * value *). Мы можем использовать это для настройки или тестирования для предварительных условий в состояние, например, если метод «основной» добавляет тег в объект, метод * on out intry * может проверить, что существует категория и тег.

Имя метода может быть указано как относительный путь к локальному классу (то есть только имя метода) или в синтаксисе пространства имен/класс/метод.

Примечание - Некоторые старые государственные машины, такие как _/инфраструктура/vm/provisoning/statemachines/provisionRequestApproval/_ Используйте * на входе * _method_ вместо * значения * _relationship_ для выполнения основной работы штата. С появлением «метода ::», описанный выше, это использование устарело, и мы всегда должны использовать соотношение * значения * в наших государственных машинах.

===== On Exit

При желании мы можем определить * на выходе * _method_, чтобы запустить, если метод «Main» (значение * value * intempt/incestion или * on intry * method) возвращает `$ evm.roo ['ae_result'] = 'ok'`'

===== On Error

При желании мы можем определить * на ошибке * _method_, чтобы запустить, если метод «Main» ( * value * intempt/instance или * on intry * method) возвращает `$ evm.roo ['ae_result'] = 'error'’ `

===== Max Retries

При желании мы можем определить максимальное количество повторных поисков, которые государству разрешено пытаться. Определение этого в состоянии, а не в самом методе, упрощает кодирование метода и облегчает написание общих методов, которые можно повторно использовать в ряде государственных машин.

===== Max Time

Мы можем при желании определить максимальное время (в секунды), что государству будет разрешено работать, прежде чем быть прекращенным.

==== State Machine Example

Мы можем взглянуть на необычайную _/инфраструктуру/VM/провинции/StateMachines/provisionRequestApproval/default_ в качестве примера, и убедитесь, что он определяет четыре атрибута и имеет только два состояния; *ValiveAteRequest*и ** ApprovereQuest ** (см. << i3 >>).

[[i3]]
.Th /provisionRequestApproval /State Match
image::images/ss2.png[Screenshot,700,align="center"]
{zwsp} +

Ни одно государство не имеет отношения * значения *, но каждый из них работает локально определенным методом класса для выполнения основной обработки состояния.

Состояние * valiveAteRequest * запускает метод _validate_request_ * on intry * и _pending_request_ как метод * на ошибке *.

Состояние * ApprovereQuest * запускает метод _prove_Request_ * при входе *.

=== State Variables

Существует несколько переменных состояния, которые могут быть прочитаны или установлены методами состояния для управления обработкой государственной машины.

==== Setting State Result

Мы можем запустить метод в контексте состояния машины, чтобы вернуть статус завершения в механизм автоматизации, который затем решает, какое следующее действие будет выполнять (например, перейти к следующему состоянию).

Мы делаем это, установив одно из трех значений в хэш -клавише `ae_result`:

[source,ruby]
----
# Сигнализировать об ошибке
$ evm.root ['ae_result'] = 'ошибка'
$ evm.root ['ae_reason'] = "не удалось что -то сделать"

# Сигнал о том, что шаг следует повторно
$ evm.root ['ae_result'] = 'retry'
$ evm.root ['ae_retry_interval'] = '1.minute'

# Сигнал о том, что шаг успешно завершился
$ evm.root ['ae_result'] = 'ok'
----

==== State Retries

Мы можем выяснить, находимся ли мы на шаге, который повторно подходит, запрашивая ключ `ae_state_retries`:

[source,ruby]
----
state_retries = $ evm.root ['ae_state_retries'] || 0
----

==== Getting the State Machine Name

Мы можем найти название государственной машины, в которой мы работаем:

[source,ruby]
----
state_machine = $ evm.current_object.class_name
----

==== Getting the Current Step in the State Machine

Мы можем выяснить, какой шаг (состояние) в штате, в котором мы выполняем (полезно, если у нас есть общий метод обработки ошибок):

....
step = $ evm.root ['ae_state']
....

==== Getting the on_entry, on_exit, on_error Status State

Метод может определить, в каком состоянии состояния (on_entry, on_exit или on_error) оно в настоящее время выполняется, следующим образом:

[source,ruby]
----
Если $ evm.root ['ae_status_state'] == "on_entry"
  ...
----

==== Error Recovery

Метод ** on_error ** имеет возможность выполнить действие восстановления из условия ошибки и установить `$ evm.root ['ae_result'] = 'Продолжить' ', если это необходимо, чтобы обеспечить продолжение состояния.

==== Skipping States

Чтобы допустить интеллектуальную ** on_entry ** Предварительную обработку и продвигать, если предварительные условия уже будут выполнены, метод ** on_entry ** может установить `$ evm.root ['ae_result'] = 'Skip'` для продвижения непосредственно к следующему состоянию, не называя метод« стоимости »текущего состояния.

==== Jumping to a Specific State

Любой из наших методов машины состояния может установить `$ evm.root ['ae_next_state'] = <Tave_Name>`, чтобы позволить машине состояния продвигаться вперед на несколько шагов.

Примечание. Настройка `ae_next_state` только позволяет нам идти вперед в состоянии состояния. Если мы хотим вернуться в предыдущее состояние, мы можем перезапустить штатную машину, но установить `ae_next_state` на имя состояния, в котором мы хотим перезапустить. При выпуске перезапуска, если `ae_next_state` не указан, машина состояния перезагрузится в первом состоянии.

[source,ruby]
----
# В настоящее время в State4
$ evm.root ['ae_result'] = 'перезапуск'
$ evm.root ['ae_next_state'] = 'state2'
----

==== Nested State Machines

Как было упомянуто, поле «Значение * государственной машины должно быть отношением к экземпляру». Мы также можем вызвать всю машину штата с шага в машине «родитель», если мы желаем (см. << i4 >>).

[[i4]]
. Недоверенные государственные машины
image::images/ss3.png[Nested State Machines,350,align="center"]
{zwsp} +

=== Saving Variables Between State Retries

Когда шаг повторно отнесен на государственную машину, двигатель автоматизации восстанавливает всю государственную машину, начиная с государства, выдавающего попытку.

[NOTE]
====
Вот почему государственные машины не должны содержать строки, в которых *тип *типа *поле *Отношения *. Государство - это особый вид отношений, которые можно пропустить во время повторных рисков. Если бы у нас была линия * отношений * в любом месте нашей государственной машины, то она была бы повторно заполнена каждый раз, когда более позднее * состояние * выпускало `$ evm.root ['ae_result'] = 'retry'`.
====

Это восстановление затрудняет жизнь, если мы хотим хранить и извлекать переменные между шагами в государственной машине (что мы часто хотим делать). К счастью, есть три метода `$ evm`, которые мы можем использовать для проверки наличия, сохранения и считывания переменных между восстановлением нашей государственной машины:

[source,ruby]
----
$ evm.set_state_var (: server_name, "myserver")
Если $ evm.state_var_exist? (: server_name)
server_name = $ evm.get_state_var (: server_name)
конец
----

Мы можем сохранить большинство типов переменных, но из -за закулисной механики мы не можем сохранить хэши, которые имеют инициализаторы по умолчанию, например,

[source,ruby]
----
my_hash = hash.new {| h, k | h [k] = {}}
----

Здесь `| h, k | h [k] = {} ` - функция инициализатора.

=== Summary

Государственные машины невероятно полезны, и мы часто используем их для создания собственных интеллектуальных, многоразовых рабочих процессов. Они позволяют нам сосредоточиться на логике наших методов состояния, в то время как механизм автоматизации обрабатывает сложность обработки условий на входе и исходах и логики повторения состояния.

При принятии решения о том, следует ли внедрить рабочий процесс в качестве государственной машины, рассмотрите следующее:

* Могу ли я пропустить любой из своих шагов рабочих процессов с помощью разумной предварительной обработки?

* Будет ли мой код чище, если бы я мог предположить, что предварительные условия были настроены или протестированы до входа?

* Может ли какой -либо из моих шагов рабочего процесса привести к ошибке, с которой можно было бы обработать и выздороветь?

* Требует ли каких -либо из моих шагов рабочего процесса, чтобы я повторно повторил операцию в цикле ожидания?

* Нужно ли положить тайм -аут на свой рабочий процесс?

Если ответ на любой из этих вопросов - «да», то штатная машина является хорошим кандидатом для реализации.

==== Further Reading
http://talk.manageiq.org/t/automate-state-machine-enhancements/678/17* Улучшение государственной машины.
