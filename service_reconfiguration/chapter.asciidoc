[[service-reconfiguration]]
== Реконфигурация обслуживания

Наши рабочие процессы, обеспечивающие виртуальную машину или экземпляры, до сих пор создали новые готовые виртуальные машины или виртуальные машины, интегрированные со спутником 6, чтобы можно было применить конфигурацию марионеток. (См. << Интеграция с сателлитом-6-дюймом-провидением >>).

В этих случаях мы должны войти в две отдельные системы, чтобы привлечь наши предоставленные и настроенные серверы. Мы вошли в WebUI Manageiq, чтобы запустить операцию по обеспечению, и второй веб -сайт для платформы управления конфигурацией, такой как спутник, для установки или сброса параметров конфигурации.

Когда мы предоставляем новые виртуальные машины в качестве сервисов, однако мы можем консолидировать функции обеспечения и конфигурации в одном пользовательском интерфейсе. Мы можем установить первоначальные параметры конфигурации в диалоговом окне службы, а затем отметить службу как _reconfigeraill_, чтобы эти параметры были обновлены из того же диалога службы Manageiq.

Это использование дуэли диалога услуг для начальной конфигурации и реконфигурации работает хорошо, если мы используем инструмент управления конфигурацией, такой как спутник 6 и Puppet. Мы можем указать Puppet _smart Class Parameters_ в нашем диалоговом окне службы, который можно передать в мастер и использовать для переопределения статически определенных параметров класса кукол.

=== Reconfigure Entry Point

До сих пор, когда мы создали наши элементы каталога сервисов, мы указали машину состояния точки входа для обработки рабочего процесса для нового услуги. Есть две другие точки входа, в которые мы можем при желании подключиться, точка выхода на пенсию (см. << Повторное восстановление >>) и точку входа в реконфигурирование (см. << C38I1 >>).

[[c38i1]]
. Устанавливает точку входа в реконфигурацию при создании элемента службы
image::images/ss1.png[Screenshot,700,align="center"]
{zwsp} +

Если мы создадим элемент каталога услуг, чтобы иметь машину состояния точки входа в реконфигурирование, то любая услуга, созданная из этого элемента каталога

[[c38i2]]
.Reconfiguring a service
image::images/ss2.png[Screenshot,500,align="center"]
{zwsp} +

Если мы выберем эту опцию, нам еще раз представлено оригинальный диалог службы. Ввод новых значений и нажатие кнопки * отправить * создаст _servicereconfigurerequest_, чтобы PEFORM Reonfiguration Dection, на основе пересмотренных значений, которые мы ввели в диалог.

=== Service Design

Когда мы создаем услугу, которая может быть перенастроена таким образом, нам нужно дополнительные размышления о нашем дизайне услуг и обеспечивающем рабочем процессе. Нам нужно сделать некоторые из наших элементов диалога с сервисом _reconfigerawer_, чтобы мы могли ввести новые значения при повторном представленном диалоге по запросу на реконфигурацию услуг (элементы, не отмеченные как реконфигурируемые, будут выявлены). Нам необходимо создать метод _set_configuration_, который можно вызвать либо из положения виртуальной машины, либо из машин реконфигурации службы, и извлечь значения диалога из правильного местоположения в каждом случае. Этот метод должен обнаружить, было ли инициировано положение виртуальной машины из службы, которая прошла правильные значения диалога, или интерактивный запрос о предоставлении виртуальной машины, который этого не сделал.

=== Adding a Configuration Management Provider

Мы можем добавить наш сервер Satellite 6 в CloudForms или Manageiq в качестве поставщика _configuration Management_. Это импортирует группы хостов Foreman в качестве профилей Manageiq _configuration_, сохраняя нас от необходимости сделать вызов отдыха на спутниковой сервер, чтобы перечислить их (см. << C38i3 >>).

[[c38i3]]
Профили конфигурации, импортируемые со спутника 6
image::images/ss3.png[Screenshot,700,align="center"]
{zwsp} +

=== Automate Datastore Components

Несмотря на то, что способность реконфигурации обслуживания предоставляется для нас Manageiq, нам все равно нужно добавить несколько компонентов автоматического хранилища данных, если мы хотим его использовать.

==== Creating the Namespaces and State Machines

В нашем собственном домене мы создадим _/service/Reconfiguration/statemachines_ пространство имен (см. << C38i4 >>).

[[c38i4]]
./Service/reconfiguration/statemachines пространство имен
image::images/ss4.png[Screenshot,350,align="center"]
{zwsp} +

Мы создадим простой класс машины состояния под названием _servicereconfigure_, с 7 состояниями (см. << C38i5 >>).

[[c38i5]]
.ServicereConfigure Государственная машина классная схема
image::images/ss5.png[Screenshot,600,align="center"]
{zwsp} +

* pre \ {1-3}* и* post \ {1-3}* являются заполнителями в будущем, если мы хотим улучшить функциональность в будущем. На данный момент мы просто будем использовать состояние * реконфигурации *.

Мы скопируем _manageiq/service/provisioning/statemachines/serviceprovision_template/update_serviceprovision_status_ метод в нашем домене и переименовать в _update_servicereconfigure_status_. Мы меняем линию 6 из:

[source,ruby]
....
prov = $ evm.root ['service_template_provision_task']
....
к:

[source,ruby]
....
Reconfigure_task = $ evm.root ['service_reconfigure_task']
....

Мы также изменяем имя переменной в строке 13 от +prov +на +Reconfigure_task +.

Мы отредактируем ** на запись **,*на выходе*и*на ошибке*столбцы в схеме класса машины штата для обращения к новой методе _Update_servicereConfigure_status_ (см. << C38i6 >>).

[[c38i6]]
. Настройка методов входа
image::images/ss6.png[Screenshot,450,align="center"]
{zwsp} +

Мы создаем экземпляр _default_ класса машины _servicereconfiguration_ состояния, и мы укажем на * Reconfigure * на _/интеграция/спутниковые/методы/setConfiguration_, который мы создаем (см. << C38i7 >>).

[[c38i7]]
.Schema экземпляра по умолчанию
image::images/ss7.png[Screenshot,450,align="center"]
{zwsp} +

==== Email Classes

Нам нужно создать два новых экземпляра электронной почты с соответствующими методами, чтобы отправлять электронные письма, когда реконфигурация службы одобрена и завершена. Для удобства мы просто скопируем, переименованы и отредактируем экземпляры и методы _manageiq/service/provisioning/email_ (см. << C38i8 >>).

[[c38i8]]
. КОПИДЕНИЕ И ПЕРЕСМУЩЕНИЕ ЭКСПОЛНИТЕЛЬНЫХ И МЕТОДА
image::images/ss8.png[Screenshot,350,align="center"]
{zwsp} +

==== Policies

Нам нужно генерировать экземпляры политики для двух событий ServiceReconfigure, _ServicereConfigurereQuest_created_ и __servicereconfigurerequest_pruped__.

Мы копируем _manageiq/system/policy/serviceTemplateProvisionRequest_created_ в наш домен как _System/policy/servicereconfigurerequest_created_. Мы можем оставить содержимое схемы такими, какие они есть, потому что мы будем использовать ту же автоматическую машину состояния автоматического одобрения, что и когда услуга была первоначально предоставлена.

We copy _ManageIQ/System/Policy/ServiceTemplateProvisionRequest_approved_ into our domain as _/System/Policy/ServiceReconfigureRequest_approved_, and we edit the *rel5* state to point to our new _/Service/Reconfiguration/Email/ServiceReconfigurationRequestApproved_ email instance (see <<c38i9>>).

[[c38i9]]
. КОПИИ И ПЕРЕСМУЩЕНИЕ ПОЛИТИКИ
image::images/ss9.png[Screenshot,350,align="center"]
{zwsp} +

=== Modifying the VM Provision Workflow

Нам нужно изменить наш рабочий процесс VM Provision, чтобы добавить состояние для выполнения начальной конфигурации, используя входные значения из диалога службы. Мы возьмем машину состояния, которую мы использовали в << Integrating-With-Satellite-6-Duging-Provisioning >> и добавим*SetConfiguration*Stage после ** Registersatellite **. * SetConfiguration* указывает на тот же экземпляр, что и наш новый _servicereconfiguration_ State Machine* Reconfigure* Stage (см. << C38i10 >>).

[[c38i10]]
. Добавление стадии SetConfiguration к машине государственного обеспечения виртуальной машины
image::images/ss10.png[Screenshot,600,align="center"]
{zwsp} +

=== Service Dialog

Мы собираемся создать полностью динамичный диалог обслуживания, взаимодействуя со спутником для получения информации. Диалог будет искать VMDB для профилей конфигурации (группы хостов) и представит их в раскрывающемся списке. Для выбранной группы хоста спутник будет запрошен для настроенных клавиш активации и классов кукол, и они будут представлены в раскрывающихся списках. Для выбранного класса марионеток будет запрошен спутник для доступных параметров интеллектуального класса, и они будут представлены в раскрывающемся списке. Наконец, ящик для текстовой области будет представлена ​​для необязательного ввода параметра переопределения.

==== Elements

Диалог услуг будет содержать семь элементов, из которых ** класс Puppet **,*Smart Class Parameter*и*Новое значение параметра*элементы будут помечены как*реконфигурируемые*. Элементы диалога суммированы в << C38T1 >>.

[[c38t1]]
.Dialog Элементы
[options="header"]
|=======
| Имя | Тип | Динамический | Экземпляр | Автоматическое обновление | Автоматическое обновление других полей | Reconfigeraled
| Имя службы | Текстовое поле | Нет | N/A | N/A | N/A | Нет
| Vm name | текстовое поле | Нет | n/a | n/a | n/a | no
| Группа хоста | раскрывающийся список | Да | Listostgroups | Нет | Да | Нет
| Ключ активации | раскрывающийся список | Да | ListActivationKeys | Да | Нет | Нет
| Кукольный класс | раскрывающийся список | Да | ListPuppetClasses | Да | Да | Да
| Параметр интеллектуального класса | раскрывающийся список | Да | ListSmartClassParameters | Да | Нет | Да
| Значение нового параметра | Комплекс текстовой области | Нет | n/a | n/a | n/a | Да
|=======

При заказе диалог будет выглядеть как << C38I12 >>).

[[c38i12]]
. Окончательный диалог обслуживания
image::images/ss12.png[Screenshot,500,align="center"]
{zwsp} +

=== Instances and Methods

Нам нужно создать ряд экземпляров и методов, чтобы заполнить динамические элементы диалога диалога службы.

==== Dynamic Dialogs

Динамические экземпляры и методы диалога определяются в рамках _/интеграции/спутника/DynamicDialogs_ Пространство имен в нашем домене (см. << C38I13 >>).

[[c38i13]]
.Dannamic Диалоговые экземпляры и методы
image::images/ss13.png[Screenshot,350,align="center"]
{zwsp} +

Схема для класса _methods_ содержит переменные, содержащие учетные данные для подключения к нашему спутниковому серверу (мы сначала использовали эту технику в << с использованием chema-variables >>).

===== Common Functionality

Каждый из динамических методов имеет простой метод _REST_ACTION_ для выполнения RESTFUL CALL со спутником:

[source,ruby]
----
def rest_action (uri, глагол, полезная нагрузка = nil)
заголовки = {
: content_type => 'Application/json',
: Accept => 'Application/json; версия = 2',
: Authorization => \
"Basic#{base64.strict_encode64 ("#{@username}:#{@пароль} ")}"
  }
response = restClient :: request.new (
: method => глагол,
: url => uri,
: ghingers => Headers,
: PAYTOAD => PAWEROAD,
verify_ssl: false
).выполнять
return json.parse (response.to_str)
конец
----

Каждый из них извлекает учетные данные из схемы экземпляра, определяет базовый URI и пустые значения_hash:

[source,ruby]
----
servername = $ evm.object ['servername']
@UserName = $ evm.Object ['username']
@password = $ evm.object.decrypt ('пароль')

uri_base = "https: //#{servername}/api/v2"
values_hash = {}
----

===== ListHostGroups

Метод _List_hostgroups_ не нуждается в подключении к API спутникового отдыха, поскольку спутниковый сервер зарегистрирован в качестве поставщика управления конфигурацией. Метод выполняет простой поиск VMDB всех профилей конфигурации:

[source,ruby]
----
hostgroups = $ evm.vmdb (: configuration_profile). Все

Если hostgroups.length> 0
Если hostgroups.length> 1
values_hash ['!'] = '-выберите из списка-'
конец
hostgroups.each do | hostgroup |
$ evm.log (: info, "Найденная группа хостов '#{hostgroup.name}' \
с id: #{hostgroup.manager_ref} ")
values_hash [hostgroup.manager_ref] = hostgroup.name
конец
еще
values_hash ['!'] = 'Группы хост не доступны'
конец
----

===== ListActivationKeys

Метод _List_activationKeys_ извлекает hostgroup_id из элемента группы * хоста * и делает позвоночник спутникового API, чтобы получить параметры GOSTGROUP:

[source,ruby]
----
hg_id = $ evm.object ['dialog_hostgroup_id']

Если hg_id.nil?
values_hash ['!'] = "Выберите группу хоста и нажмите« Обновление »"
еще
REST_RETURN = REST_ACTION ("#{uri_base}/hostgroups/#{hg_id}/parameters" ,: get)
REST_RETURN ['Результаты']. Каждый делает | HOSTGROUP_PARAMETER |
Если hostgroup_parameter ['name']. to_s == "kt_activation_keys"
hostgroup_parameter ['value']. ​​Split (','). Каждый делает | ActivationKey |
values_hash [activationKey] = activationKey
конец
конец
конец
if values_hash.length> 0
if values_hash.length> 1
values_hash ['!'] = '-выберите из списка-'
конец
еще
values_hash ['!'] = 'У этой группы хостов нет ключей активации'
конец
конец
----

===== ListPuppetClasses

Метод _List_puppetClasses_ извлекает hostgroup_id из элемента * host * house * и делает звонок с спутником API, чтобы получить классы кукол, связанные с группой хоста:

[source,ruby]
----
hg_id = $ evm.object ['dialog_hostgroup_id']

Если hg_id.nil?
values_hash ['!'] = "Выберите группу хоста и нажмите« Обновление »"
еще
REST_RETURN = REST_ACTION ("#{uri_base}/hostgroups/#{hg_id}/puppetclasses" ,: get)
Если REST_RETURN ['Total']> 0
if rest_return ['otting']> 1
values_hash ['!'] = '-выберите из списка-'
конец
REST_RETURN ['Результаты']. Каждый DO | ClassName, ClassInfo |
values_hash [classinfo [0] ['id']. TO_S] = classname
конец
еще
value_hash ['!'] = 'Классы кукол не определены для этой группы хост' '
конец
конец
----

===== ListSmartClassParameters

Метод _list_smart_class_parameters_ извлекает в предыдущие элементы hostgroup_id и PuppetClass_id и делает Satellite API, чтобы получить параметры Puppet Smart Class, связанные с группой хоста. Для каждого параметра возвращался его, а затем делает еще один сателлитный вызов API для перекрестной ссылки против запрошенного класса Puppet:

[source,ruby]
----
hg_id = $ evm.object ['dialog_hostgroup_id']
puppet_class_id = $ evm.object ['dialog_puppet_class_id']

Если puppet_class_id.nil?
values_hash ['!'] = "Выберите класс кукол и нажмите« Обновить »»
еще
call_string = "#{uri_base}/hostgroups/#{hg_id}/smart_class_parameters"
rest_return = rest_action (call_string ,: get)
REST_RETURN ['Результаты']. Каждый делает | Параметр |
    #
# Получить детали этого параметра интеллектуального класса
# выяснить, какой класс кукол он связан с
    #
call_string = "#{uri_base}/hostgroups/#{hg_id}/"
call_string += "smart_class_parameters/#{parameter ['id']}"
parameter_details = rest_action (call_string ,: get)
if parameter_details ['PuppetClass'] ['id']. TO_S == Puppet_class_id
values_hash [parameter ['id']. to_s] = parameter_details ['parameter']
конец
конец
if values_hash.length> 0
if values_hash.length> 1
values_hash ['!'] = '-выберите из списка-'
конец
еще
values_hash ['!'] = 'Этот класс кукол не имеет параметров интеллектуального класса'
конец
конец
----

Таким образом, создание нескольких вызовов API с перекрестными привязанными к спутнику может быть медленным, если в нашей группе хозяина определяется много классов марионеточных классов с интеллектуальным классом, но этот метод подходит для нашего примера.

==== Configuration-Related Methods

У нас есть три метода, которые обрабатывают регистрацию со спутником и настройкой конфигурации.

===== RegisterSatellite

Мы редактируем метод _register_satellite_ от << интеграция в satellite-6-duging-provisioning >>, чтобы вывести жестко-кодированный выбор группы хостов. Мы также полностью обходимся в спутниковой регистрации, если не найдем hostgroup_id:

[source,ruby]
----
#
# Зарегистрируйтесь только в том случае, если шаблон подготовки является Linux
#
Если Template.platform == "linux"
  #
# Зарегистрируйтесь только на спутнике, если мы прошли
# Идентификатор хост -группы из диалога службы
  #
hg_id = $ evm.root ['miq_provision']. get_option (: dialog_hostgroup_id)
Если только hg_id.nil?
    ...
----

===== ActivateSatellite

Мы редактируем метод _Activate_satellite_ от << интеграция в satellite-6-duging-provisioning >>, чтобы вывести жесткий выбор ключа активации. Мы также полностью обходимся спутниковую активацию, если не найдем имя ключа активации:

[source,ruby]
----
#
# Зарегистрируйтесь только в том случае, если шаблон подготовки является Linux
#
prov = $ evm.root ['miq_provision']
Если Template.platform == "linux"
  #
# Зарегистрируйтесь и активируйтесь со спутником, если мы прошли
# Ключ активации из диалога службы
  #
ActivationKey = prov.get_option (: dialog_activationKey_name)
Если только ActivationKey.nil?
    ...
----

===== SetConfiguration

Метод _set_configuration_ будет вызван из двух совершенно разных машин состояния, один раз для выполнения начальной конфигурации во время обеспечения и, возможно, снова во время запроса на реконфигурирование службы. Метод должен получить значения диалога услуг из любого из двух разных мест:

[source,ruby]
----
Если $ evm.root ['vmdb_object_type'] == 'miq_provision'
prov = $ evm.root ['miq_provision']
parameter_id = prov.get_option (: dialog_parameter_id)
parameter_value = prov.get_option (: dialog_parameter_value)
hg_id = prov.get_option (: dialog_hostgroup_id)
hostname = prov.get_option (: dialog_vm_name)
elsif $ evm.root ['vmdb_object_type'] == 'service_reconfigure_task'
parameter_id = $ evm.root ['dialog_parameter_id']
parameter_value = $ evm.root ['dialog_parameter_value']
hg_id = $ evm.root ['dialog_hostgroup_id']
hostname = $ evm.root ['dialog_vm_name']
конец
----

Если значение переопределения параметра интеллектуального класса не было введено, метод просто выходит:

[source,ruby]
----
  #
# Установите параметр Smart Class только в том случае, если мы прошли
# значение параметра из диалога службы
  #
Разве параметр_value.nil?
     ...
----

Метод должен получить доменное имя по умолчанию из группы хоста, чтобы собрать правильный FQDN для матча:

[source,ruby]
----
REST_RETURN = REST_ACTION ("#{uri_base}/hostgroups/#{hg_id}" ,: get)
domain_name = rest_return ['domain_name']
match = "fqdn =#{hostname}.#{domain_name}"
----

Метод также должен определить, существует ли совпадение переопределения. Если он не существует, он должен быть создан с помощью поста после действия; Если это существует, должно быть обновлено с помощью действия:

[source,ruby]
----
call_string = "#{uri_base}/smart_class_parameters/"
call_string += "#{parameter_id}/overide_values"
rest_return = rest_action (call_string ,: get)
override_value_id = 0
Если REST_RETURN ['Total']> 0
REST_RETURN ['Результаты']. Каждый делает | override_value |
if override_value ['match'] == match
override_value_id = override_value ['id']
конец
конец
конец
Если override_value_id.zero?
PAYLOAD = {
: match => match,
: value => parameter_value
  }
call_string = "#{uri_base}/smart_class_parameters/"
call_string += "#{parameter_id}/overide_values"
rest_return = rest_action (call_string ,: post, json.generate (payload))
еще
PAYLOAD = {
: value => parameter_value
  }
call_string = "#{uri_base}/smart_class_parameters/"
call_string =+ "#{parameter_id}/overide_values/#{overide_value_id}"
rest_return = rest_action (call_string ,: put, json.generate (полезная нагрузка))
конец
----

Здесь мы видим, что + Match + является FQDN сервера. Если совпадение переопределения не существует для этого параметра смарт -класса, мы создаем один, используя сервер FQDN и значение для переопределения. Если совпадение переопределения на основе FQDN существует, мы просто обновляем значение переопределения.

Полный код для методов
https://github.com/pemcg/oreilly-mastering-cloudforms-automation/tree/master/chapter38/scripts®]

=== Testing

Мы закажем новую услугу и выберем соответствующую группу хоста и ключи активации из раскрывающихся. Мы выберем класс кукол _motd_ и переопределим параметр _content_ Smart Class (см. << C38i14 >>).

[[c38i14]]
. Устанавливает начальное значение для MOTD при провале услуги
image::images/ss14.png[Screenshot,550,align="center"]
{zwsp} +

Мы нажимаем *отправить *и ждем нашу недавно предоставленную услугу.

Вход в недавно предоставленный сервер подтверждает, что MOTD был установлен:

....
Последний логин: ср 23 марта 17:14:34 2016 от Miq05.bit63.net
#
Следующее собрание команды 23 апреля 2016 года
#
[root@rhel7srv034 ~]#
....

Если мы посмотрим на детали нашей новой службы в*My Services*и выберите ** Configuration -> Reonfigure This Service **, мы снова представлены с диалогом службы, но элементы, не помеченные как*Reconfigeraired*только для чтения (см. << C38I15 >>).

[[c38i15]]
. Устанавливает новое значение для MOTD при реконфигурировании сервиса
image::images/ss15.png[Screenshot,550,align="center"]
{zwsp} +

Мы можем снова выбрать класс кукол _motd_, введите новое значение для параметра _content_ Smart Class и нажмите ** Отправить **.

Мы получаем электронное письмо с информированием, что запрос на реконфигурацию был утвержден:

....
Привет,
Ваш запрос на реконфигурацию вашего обслуживания был утвержден. Если реконфигурация обслуживания
успешно, вы будете уведомлены по электронной почте, когда услуга будет доступна.

Утверждающие Примечания: Автоматическое одобрение

Для просмотра этого запроса перейдите по адресу: https: // miq05/miq_request/show/1000000000109

Спасибо,
Команда инфраструктуры виртуализации
....

Мы можем войти в пользовательский интерфейс Satellite 6, чтобы подтвердить, что «значение переопределения для конкретных хостов» содержит наше обновленное значение против фильтра соответствия (см. << C38I16 >>).

[[c38i16]]
. Подтверждение параметра марионеточного интеллектуального класса в спутнике
image::images/ss16.png[Screenshot,550,align="center"]
{zwsp} +

Как только агент марионетки снова запустится на клиенте, мы можем войти в систему и увидеть новое сообщение:

....
Последний логин: ср. 23 марта 17:35:50 2016 от Miq05.bit63.net
#
Следующая Q/A Дата встречи команды изменилась, теперь 21 апреля 2016
#
#[root@rhel7srv034 ~]#
....

=== Summary

Эта глава основывается на нескольких темах и примерах, которые мы проработали до сих пор в книге. Он расширяет интеграцию со спутником 6, которую мы рассмотрели в << Integrating-with-satellite-6-Duging-Provisioning >>, и показывает, как мы можем динамически представлять списки клавиш активации или классы кукол со значениями, полученными с спутникового сервера во время выполнения. Мы настроили некоторые элементы диалога службы на автоматическое обоснование, так что выбор, изготовленный из одного элемента, автоматически запускает методы обновления для заполнения других зависимых элементов. Некоторые из элементов диалога также были реконфигурируемыми, так что их значения могут быть обновлены. Это довольно продвинутый пример, который показывает, что можно сделать из каталога услуг.

Наконец, этот пример основан на концепции использования служб в качестве оркестраторов рабочей нагрузки и показывает, как мы можем установить и обновить нашу конфигурацию службы из одного инструмента. Это мощная концепция и означает, что мы можем использовать наш каталог услуг в качестве единственной контрольной точки для развертывания и настройки наших рабочих нагрузок.


