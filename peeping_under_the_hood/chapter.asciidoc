[[peeping-under-the-hood]]
== Поглядываясь под капюшоном

Теперь мы работали с объектом двигателя автоматизации, который представляет виртуальную машину, и мы назвали один из его методов, чтобы добавить пользовательский атрибут в виртуальную машину.

В этой главе мы более глубоко рассмотрим эти объекты двигателя автоматизации, и на некоторых технологиях, которые существуют за кулисами в рельсах, когда мы запускаем сценарии автоматизации. Это полезная справочная информация, но может быть пропущена на первом чтении, если это необходимо.

=== A Little Rails Knowledge (Goes a Long Way)

Во -первых, в виде заверения ...

*Нам не нужно знать Ruby on Rails, чтобы написать сценарии автоматизации*.

Однако может быть полезно иметь оценку рельсов __models__, и как двигатель автоматизации инкапсулирует их как предметы Ruby, с которыми мы можем программировать. Объекты представляют вещи, которые нас обычно интересуют, когда мы пишем код автоматизации, такие как виртуальные машины, кластеры, гостевые приложения или даже предварительные запросы.

==== Plain Old Ruby

Рубиновые сценарии, которые мы пишем, являются просто Ruby 2.x, хотя активные расширения ядра поддержки на Ruby доступны, если мы хотим их использовать.

[NOTE]
Активные расширения поддержки могут облегчить нашу жизнь. Например, вместо того, чтобы добавлять математику в наш сценарий автоматизации, чтобы выработать количество секунд за двухмесячный промежуток времени (возможно, для указания пенсионного периода виртуальной машины), мы можем просто указать `2. Манты.

Наши сценарии автоматизации получают доступ к объектам Ruby, предоставленные нам механизмом автоматизации через переменную `$ evm` (` $ evm` более подробно описан в ссылке: ../ evm_and_the_workspace/grail.asciidoc [$ evm и рабочего пространства]). За кулисами это объекты Rails, поэтому некоторое понимание рельсов может помочь нашему исследованию того, как мы можем использовать эти объекты для нашей максимальной выгоды.

==== Model-View-Controller

Rails-это приложение Model-View-Controller (MVC): [см. Также http://en.wikibooks.org/wiki/ruby_on_rails/getting_started/model-view-controller=
на рельсах/начало работы/модели-визитный контроллер]]]

[[i1]]
.AN MVC Приложение
image::images/mvc.png[Screenshot,450,align="center"]
{zwsp} +

_Model_ является представлением базовой логической структуры данных из базы данных (которая в случае Cloudforms и Manageiq - Postgresql). При написании сценариев автоматизации мы много работаем с моделями (хотя мы не обязательно осознаем это).

Модели Rails называются _active Records_. У них всегда есть единственное число _camelcase_ (например, GuestApplication), а соответствующие таблицы базы данных имеют множественное число _snake_case_ имени (например, Guest_applications).

==== Active Record Associations

Active Record _associations_ Свяжите модели вместе в отношениях один-один или один на один, которые позволяют нам пересекать объекты.

Мы можем проиллюстрировать это, посмотрев на некоторые из кода Rails, который определяет активную запись _host_ (то есть гипервизор):

[source,ruby]
----
Ведущий класса <activerecord :: base
  ...
принадлежности_TO: ext_management_system,: retial_key => "ems_id"
принадлежит_TO: ems_cluster
has_one: hoparing_system,: зависит
has_one: аппаратное обеспечение ,: зависимое =>: уничтожить
has_many: vms_and_templates,: зависит =>: nullify
has_many: VMS
  ...
----

Мы видим, что есть несколько ассоциаций из хост -объекта, в том числе до кластера, которым он является членом, и для виртуальных машин, которые работают на этом
хозяин.

Хотя эти ассоциации определены в рельсах, они доступны для нас, когда мы работаем с соответствующими объектами _service model_ из движения автоматизации (см. << Service-Models >>).

==== Rails Helper Methods (.find_by_*) 

Rails делает много вещей, чтобы облегчить нашу жизнь, в том числе динамическое создание __helper Methods__. Наиболее полезными для нас в качестве сценариев автоматизации являются методы find_by_columnname.

[source,ruby]
----
vm = $ evm.vmdb ('vm'). find_by_name (vm_name)
----

Мы можем `.find_by_` Имя столбца в таблице базы данных. Например, в PostgreSQL мы можем посмотреть на таблицу _Services_, которая представляет услуги, созданные с помощью каталога услуг.

....
vmdb_production =# \ d Services
Таблица "public.services"
Колонка |            Тип |                 Модификаторы
----------------------+-----------------------------+---------------------------
id | bigint | Не null default nextva ...
имя | Персонал варьируется (255) |
Описание | Персонал варьируется (255) |
Guid | Персонал варьируется (255) |
Тип | Персонал варьируется (255) |
service_template_id | bigint |
Варианты | Текст |
дисплей | логический
 ...
....

Мы видим, что есть столбец «Описание», поэтому, если мы хотим, мы могли бы позвонить:

[source,ruby]
----
$ evm.vmdb ('service'). find_by_description («Моя новая служба»)
----

Более ранние версии Rails также имели метод ‘find_all_by_*` helper, который вернул все результаты, соответствующие поиску. Rails 5 удалил это в пользу «где», которое теперь также поддерживается моделями обслуживания. Синтаксис использования `где будет следующим образом:

[source,ruby]
----
$ evm.vmdb ('service'). где (: description => 'моя новая служба')
----

[NOTE]
`где` возвращает список, даже если он находит только один элемент

[[service-models]]
=== Service Models

Ранее мы видели, что модели данных Rails называются _active Records_. Мы не можем получить доступ к ним непосредственно из сценария автоматизации, но, к счастью, большинство полезных из них предоставляются нам в качестве объектов автоматизации _service model_.

Объекты, с которыми мы работаем в двигателе автоматизации, являются моделями обслуживания; экземпляры класса _miqaeservice_, который абстрагирует и предоставляет нам соответствующую активную запись Rails.

Например, если мы работаем с объектом _user_ (представляющий человека, таким как владелец виртуальной машины), мы можем получить доступ к этому объекту в нашем сценарии через `$ evm.root ['user']`. Это на самом деле экземпляр класса _miqaeserviceuser_, который представляет соответствующую активную запись Rails _user_. Существуют объекты модели обслуживания, представляющие все вещи, с которыми нам нужно работать, когда мы пишем сценарии автоматизации. К ним относятся традиционные компоненты в нашей инфраструктуре, такие как виртуальные машины, кластеры гипервизора, операционные системы или адаптеры Ethernet, а также нематериальные объекты, такие как задачи по обеспечению или задачи автоматизации.

Все объекты miqaeservice* расширяют общий класс _miqaeservicemodelbase_, который содержит некоторые общие методы, доступные для всех объектов, таких как
как:

....
.tagged_with? (Категория, имя)
.tags (категория = ноль)
.tag_assign (Tag)
....

Например, многие из объектов модели обслуживания имеют несколько уровней суперкласса:

....
Miqaeservicemanageiq_providers_redhat_inframanager_provisionviapxe <
Miqaeservicemanageiq_providers_redhat_inframanager_provision <
Miqaeservicemiqprovision <
Miqaeservicemiqrequesttask <
Miqaeservicemodelbase
....

==== Service Model Names and Provider Namespacing

Названия модели услуг для любых классов, специфичных для поставщика, следуют схеме размещения имен поставщиков, введенной в CloudForms 4.0 (Manageiq _Capablanca_). Это разделяет поставщиков в нескольких категориях и в текущих версиях инструментов, которые эти категории следующие:

* CloudManager
* ContainerManager
* ConfigurationManager
* Inframanager
* Network Manager

Объекты модели обслуживания, специфичные для поставщика, названы следующим образом:

....
Miqaeservicemanageiq_providers_ <providername> _ <ProviderCategory> _ <ProviderObject>
....
Например, имя объекта модели службы для облачной подсети OpenStack:
....
Miqaeservicemanageiq_providers_openstack_networkmanager_cloudsubnet
....
Имя объекта для хоста VMware ESX:
....
Miqaeservicemanageiq_providers_vmware_inframanager_hostesx
....

[NOTE]
====
Pre-Cloudforms 4.0, специфичные для поставщика имен модель услуг, были сохранены для обратной совместимости, поэтому на данный момент мы все еще можем использовать команду, такую ​​как:

....
$ evm.vmdb (: cloudsubnet). Все
....
====

=== Service Model Object Properties

Служба модели, которые предлагает нам механизм автоматизации, есть четыре свойства, с которыми мы часто работаем, _attributes_, _virtual Columns_, _associations_ и _methods_.

==== Attributes

Как и любой другой объект Ruby, объекты службы, с которыми мы работаем, имеют _attributes_, которые мы часто используем. Объект модели службы представляет запись в таблице базы данных, и атрибуты объекта соответствуют столбцам в таблице для этой записи.

Например, некоторые атрибуты для объекта Host (то есть гипервизора) (`miqaeservicemanageiq_providers_redhat_inframanager_host` модель службы), с типичными значениями, являются::

....
host.connection_state = подключен
host.created_on = 2014-11-13 17:53:34 UTC
host.ems_cluster_id = 1000000000001
host.ems_id = 1000000000001
host.ems_ref =/api/hosts/b959325b-67-4e3a-a52e-fd936c225a1a
host.ems_ref_obj =/api/hosts/b959325b-67-4e3a-a52e-fd936c225a1a
host.guid = fcea82c8-6b5d-11e4-98ac-001a4aa01599
host.hostname = 192.168.1.224
host.hyperthreading = nil
host.id = 1000000000001
host.ipaddress = 192.168.1.224
host.last_perf_capture_on = 2015-06-05 10:25:46 UTC
host.name = rhelh03.bit63.net
host.power_state = on
host.settings = {: autoscan => false,: inherit_mgt_tags => false ,: scan_frequence => 0}
host.smart = 1
host.type = hostredhat
host.uid_ems = b959325b-67-4e3a-a52e-fd936c225a1a
host.updated_on = 2015-06-05 10:43:00 UTC
host.vmm_product = rhel
host.vmm_vendor = redhat
....

Мы можем перечислять атрибуты объекта, используя:

[source,ruby]
----
this_object.attributes.each do | ключ, значение |
----

==== Virtual Columns

В дополнение к стандартным атрибутам объекта (которые соответствуют «реальным» столбцам базы данных), Rails динамически добавляет ряд _virtual Columns_ ко многим моделям службы.

[NOTE]
Виртуальный столбец - это вычисленный столбец базы данных, который не хранится физически в таблице. Виртуальные столбцы часто содержат больше динамических значений, чем атрибуты, такие как количество виртуальных машин, которые в настоящее время работают на гипервизоре.

Некоторые виртуальные столбцы для нашего объекта хоста RHEV, с типичными значениями, являются:

....
host.authentication_status = valive
host.derived_memory_used_avg_over_time_period = 790.1026640002773
host.derived_memory_use_high_over_time_period = 2586.493300608264
host.derived_memory_used_low_over_time_period = 0
host.os_image_name = linux_generic
host.platform = linux
host.ram_size = 15821
host.region_description = область 1
host.region_number = 1
host.total_cores = 4
host.total_vcpus = 4
host.v_owning_cluster = по умолчанию
host.v_total_miq_templates = 0
host.v_total_storages = 3
host.v_total_vms = 7
....

Мы получаем доступ к этим виртуальным столбцам так же, как мы получаем доступ к атрибутам, используя синтаксис "object.virtual_column_name". Если мы хотим перечислить все виртуальные столбцы объекта, получающие соответствующие значения, мы должны использовать `.send`, указав имя виртуального столбца, как так:

[source,ruby]
----
this_object.virtual_column_names.each do | virtual_column_name |
virtual_column_value = this_object.send (virtual_column_name)
----

==== Associations

Ранее мы видели, что существуют ассоциации между многими активными записями (и, следовательно, моделями обслуживания), и мы широко используем их при сценарии.

Например, мы можем узнать больше об оборудовании нашей виртуальной машины (VM), следуя ассоциациям между объектом VM (`miqaeservicemanageiq_providers_redhat_inframanager_vm`), а также его оборудование и объекты Guestdevice (` miqaeservicehardware` и `miqaeserviceguestevice), weSeServiceHardware` и` miqaEserviceguestevice, weSeServiceHardware` и `miqaeserviceguestevice.

[source,ruby]
----
Аппаратное обеспечение = $ evm.root ['vm']. Аппаратное обеспечение
ardware.guest_devices.ed do | guest_device |
Если guest_device.device_type == "Ethernet"
nic_name = guest_device.device_name
конец
конец
----

К счастью, нам не нужно ничего знать о активных записях или моделях обслуживания за кулисами, мы просто волшебным образом следуем ассоциации. См. Ссылку: ../ Spesulity_debugging/gupt.asciidoc [исследовательская отладка], чтобы выяснить, какие ассоциации следует следовать.

Продолжение нашего изучения нашего объекта Host, ассоциации, доступных для этого объекта:

....
host.datacenter
Host.directories
host.ems_cluster
host.ems_events
host.ems_folder
host.ext_management_system
хост
host.guest_applications
host.hardware
Host.lans
host.operating_system
host.storages
host.switches
host.vms
....

Мы можем перечислить ассоциации объекта, используя:

[source,ruby]
----
this_object.associations.each do | ассоциация |
----

==== Methods

Большинство объектов, с которыми мы работаем, определяют полезные методы, которые мы можем использовать, либо в их собственном классе, либо в одном из их родительских суперкласс. Например, методы, доступные для того, чтобы вызвать для нашего объекта хоста, являются:

....
host.authentication_password
host.authentication_userid
host.credentials
host.current_cpu_usage
host.current_memory_beadroom
host.current_memory_usage
host.custom_get
host.custom_keys
host.custom_set
host.domain
host.ems_custom_get
host.ems_custom_keys
host.ems_custom_set
host.event_log_threshold?
host.get_realtime_metric
host.scan
host.ssh_exec
host.tagged_with?
host.tags
host.tag_assign
....

Перечисление методов объекта модели сервиса является более сложным, потому что фактический объект, который мы хотим перечислять, работает в движке автоматизации на удаленной стороне Druby Call (см. Ниже), и все, что у нас есть, - это локальный DRB :: DRBObject, доступный из `$ evm`. Мы можем использовать `method_missing`, но мы возвращаем весь список методов, который включает имена атрибутов, имена виртуальных столбцов, имена ассоциаций, методы суперкласса и так далее.

[source,ruby]
----
this_object.method_missing (: class) .instance_methods
----

=== Distributed Ruby

Двигатель автоматизации работает в потоке CloudForms/Manageiq _Worker_, и запускает один из наших сценариев автоматизации, порождая его в качестве детского рубинового процесса. Мы можем увидеть это из командной строки, используя * `ps` *, чтобы проверить PID рабочих процессов и ее детей:


----
\ _ /var/www/miq/vmdb/lib/workers/bin/worker.rb
|   \ _/opt/rh/rh-ruby22/root/usr/bin/ruby <-сценарий автоматизации.
----

Сценарий автоматизации работает в своем собственном пространстве процесса, но он должен каким -то образом получить доступ к объектам модели службы, которые находятся в процессе автоматизации. Это происходит с использованием распределенного рубина.

. Экспонирование CloudForms/Manageiq Workings
****
Мы можем использовать `grable evm: status`, чтобы увидеть, какие работники работают на приборе Cloudforms или Manageiq:

----
VMDB
Bin/Rake EVM: статус

...
Тип работника | Статус |
-------------------------------------------------------------------+---------+
Manageiq :: Providers :: redhat :: Inframanager :: EventCatcher | начал |
Manageiq :: Providers :: redhat :: Inframanager :: MetricScollectoringworker | начал |
Manageiq :: Providers :: redhat :: Inframanager :: MetricScollectoringworker | начал |
Manageiq :: Providers :: redhat :: Inframanager :: rewreshworker | начал |
MiqemsmetricsProcessorWorker | начал |
MiqemsmetricsProcessorWorker | начал |
Miqueventhandler | начал |
Miqgenericworker | начал |
Miqgenericworker | начал |
MiqpriorityWorker | начал |
MiqpriorityWorker | начал |
MiqreportingWorker | начал |
MiqreportingWorker | начал |
Miqscheduleworker | начал |
Miqsmartproxyworker | начал |
Miqsmartproxyworker | начал |
MiquiWorker | начал |
Miqwebserviceworker | начал |
----
****

Distributed Ruby (Druby)-это распределенная объектная система клиентского сервера, которая позволяет клиентскому процессу Ruby вызовать методы на объекте Ruby, расположенном в другом (серверном) процессе Ruby. Это может быть даже на другой машине.

Объект в процессе удаленного Druby Server локально представлен в Druby Client по экземпляру объекта _drb :: drbobject_. В случае сценария автоматизации этот объект является нашей переменной `$ evm`.

Двигатель автоматизации умно обрабатывает все для нас. Когда он запускает наш сценарий автоматизации, двигатель автоматически устанавливает сеанс Druby, и мы получаем доступ ко всем объектам модели службы плавными с помощью `$ evm` в нашем сценарии. За кулисами библиотека Druby обрабатывает связь TCP/IP -сокет с Druby Server в работнике, работающем с двигателем автоматизации.

Мы понимаем это, если рассмотрим некоторые из этих объектов `$ evm` с использованием` object_walker`, например:

....
$ evm.root ['user'] => #<miqaemethodservice :: miqaeserviceuser: 0x0000000c5431c8> \
(Тип: drb :: drbobject, uri: Druby: //127.0.0.1: 388442)
....

Хотя использование Druby в основном прозрачно для нас, это может иногда давать неожиданные результаты. Возможно, мы надеемся найти какой-то полезный метод, связанный с пользователем, который мы можем вызвать на наш пользовательский объект, который, как мы знаем, мы можем получить доступ к «$ evm.root ['user']». Мы могли бы попытаться назвать стандартный метод Ruby, такой как:

[source,ruby]
----
$ evm.root ['user']. exance_methods
----

Если бы мы сделали это, мы бы действительно получили список методов экземпляра для локального объекта _drb :: drbobject_, а не удаленную модель службы MiqaeserviceUser; Наверное, не то, что мы хотим.

Когда мы становимся более предприимчивыми в наших сценариях, мы также иногда получаем возвратный объект _drb :: drbunknown_, указывая на то, что класс объекта неизвестен в пространстве имен нашего Druby.

=== Summary

Эта глава дала нам некоторую хорошую информацию о активных записях Rails, которые CloudForms/Manageiq использует внутренне для представления нашей виртуальной инфраструктуры, и как они предоставляются нам в качестве объектов модели обслуживания. Мы также видели, как эти объекты модели службы имеют четыре конкретных свойства, которые мы часто используем: атрибуты, виртуальные столбцы, ассоциации и методы.

==== Further Reading
http: //cloudforms/manageiq.org/pdf/cloudforms/manageiq-0-methods_available_for_automation-en-us.pdf [Методы доступны для автоматизации]

https://github.com/cloudforms/manageiq/cloudforms/manageiq/issues/2215= Методы автоматизации по общению через API REST]

https://github.com/cloudforms/manageiq/cloudforms/manageiq/pull/6046=, где «метод для моделей обслуживания]

Масатоши Секи: Druby Book
