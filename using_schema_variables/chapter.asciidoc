[[using-schema-variables]]
== Использование переменных схемы

В нашем простом экземпляре hello_world в предыдущей главе была очень простая схема, содержащая одно поле, которое запускало простой автономный метод. По мере того, как мы становимся более предприимчивыми с помощью автоматизации, мы обнаружим, что это может быть полезно для ассоциации переменных или _attributes_ с экземпляром. Любой метод автоматизации, запускаемый экземпляром, может считывать эти атрибуты экземпляра, что позволяет нам определять переменные или константы за пределами наших сценариев Ruby. Это упрощает обслуживание и способствует повторному использованию кода. Методы также могут записаться на эти атрибуты экземпляра, позволяя обмене степени использования между несколькими методами, которые могут выполняться в последовательности из одного и того же экземпляра.

В нашем следующем примере автоматизации мы добавим некоторые поля атрибута в нашу схему класса, установим значения для этих атрибутов в нашем экземпляре и прочитаем их из нашего метода.

=== Preparing the Schema

Давайте отредактируем схему класса _methods_ (см. << i1 >>).

[[i1]]
. Редакция схемы класса методов
image::images/ss1.png[Screenshot,500,align="center"]
{zwsp} +

Мы добавим три атрибута, _servername_, _username_ и _password_. Атрибуты _servername_ и _username_ будут простыми текстовыми строками, но атрибут _password_ будет иметь тип данных *пароля *, что означает, что он будет храниться в зашифрованной форме в базе данных (см. << i2 >>).

[[i2]]
.Dling attributes
image::images/ss2.png[Screenshot,500,align="center"]
{zwsp} +

Нажмите *Сохранить *.

Нам необходимо убедиться, что метод схемы (наше поле _execute_) указан _AFTER_ три новых атрибута схемы в списке поля, в противном случае атрибуты не будут видны методу, когда он работает. При необходимости запустите * Configuration -> Редактировать последовательность *, чтобы перетасовать поля схемы вверх или вниз (см. << i4 >>).

[[i4]]
. Редакция последовательности классов схемы
image::images/ss4.png[Screenshot,420,align="center"]
{zwsp} +

=== The Instance
Теперь мы создадим новый экземпляр в нашем классе _methods_, как и раньше, но на этот раз называется _get_credentials_. Мы заполним некоторые значения для атрибутов схемы _servername_, _username_ и _password_ (см. << i5 >>).

[[i5]]
. Включение деталей атрибута экземпляра
image::images/ss5.png[Screenshot,380,align="center""]
{zwsp} +

Обратите внимание, что наше значение схемы _password_ было запутано.

=== The Method

Каждый из атрибутов схемы будет доступен для нашего метода как пары хэш -ключа/значения от `$ evm.object`, который является объектом Automate, представляющим наш в настоящее время работающий экземпляр.

Наш код для этого примера будет следующим:

[source,ruby]
----
$ evm.log (: info "get_credentials начал")

servername = $ evm.object ['servername']
Имя пользователя = $ evm.object ['username']
пароль = $ evm.object.decrypt ('пароль')

$ evm.log (: info "Server: #{servername}, имя пользователя: #{username}, пароль: \
#{пароль}")
Выход miq_ok
----
Мы создадим метод в нашем классе _methods_, как и раньше, но на этот раз называется _get_credentials_. Мы добавим наш код в поле *Data *, нажмите *Validate *, затем *Сохранить *.

=== Running the Instance

Наконец, мы запустим новый экземпляр через * Automate -> Simulation * снова, вызывая _call_instance_ еще раз с соответствующими парами атрибута/значения (см. << i7 >>).

[[i7]]
.Argument name/value Пары для Call_instance
image::images/ss7.png[Screenshot,450,align="center"]
{zwsp} +

Мы проверяем _Automation.log_ и видим, что атрибуты были извлечены из схемы экземпляра, и пароль был расшифрован:

....
Вызов [inline] Метод [/acme/general/methods/get_credentials] с входами [{}]
<Aemethod [/acme/general/methods/get_credentials]> запуск
<Aemethod get_credentials> get_credentials начал
<Aemethod get_credentials> Сервер: myserver, username: Admin, пароль: угадайте
<Aemethod [/acme/general/methods/get_credentials]> окончание
Метод выходит с RC = MIQ_OK
....

[NOTE]
Значение пароля зашифруется с помощью _v2_key_, созданного при инициализированной базе данных CloudForms/Manageiq и уникальна для этой базы данных (и, следовательно, области). Если мы экспортируем автоматическое хранилище данных, содержащее зашифрованные пароли, и импортируем его в прибор в другой области CloudForms/Manageiq, мы не сможем расшифровать пароль.


=== Summary

В этой главе мы видели, как мы можем хранить переменные экземпляра, называемые _attributes_ в нашей схеме, которые можно получить с помощью методов, выполняемых из этого экземпляра.

Использование такими переменными схемы класса или экземпляра очень распространено. Одним из примеров является то, что мы используем CloudForms или ManageiQ для предоставления виртуальных машин. Рабочий процесс, предназначенный для виртуальной машины, включает в себя этап утверждения (см. Ссылку: ../ provisioning_proval/gupt.asciidoc [одобрение предоставления]), что позволяет нам определить дефолт для количества виртуальных машин и их размеров (процессоры и память), которые могут быть автоматическими провенированием без административного утверждения. Значения *max_vms *, *max_cpus *и *max_memory *, используемые на этом этапе рабочего процесса, хранятся в качестве атрибутов схемы в экземпляре утверждения и поэтому доступны для нас для легко настраивания без изменения какого -либо кода Ruby.

При написании наших собственных методов интеграции нам часто необходимо указывать действительное имя пользователя и пароль для подключения к другим системам за пределами CloudForms/Manageiq, например, при вызове SOAP к балансировщику аппаратной нагрузки (см. Ссылку: ../ Calling_external_services/grape.asciidoc [вызов внешним услугам] для примера). Мы можем использовать технику, показанную в этом примере, чтобы надежно хранить и извлечь учетные данные, чтобы подключиться ко всем остальным на нашем предприятии.

