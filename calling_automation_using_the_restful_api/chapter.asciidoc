[[calling-automation-from-the-restful-api]]
== Вызов автоматизации с использованием RESTFUL API

В нашем первом взгляде на возможности интеграции CloudForms и Manageiq изучает, как внешние системы могут сделать вызовы _inbound_ на прибор для запуска экземпляров автоматизации с использованием RESTFUL API.FOOTNOTE: [Нам необходимо включить роль _WEB Services_ на любом из наших приборов, в которые мы хотим совершить RESTFOL -Calls]

Способность вызовать автоматизацию таким образом позволяет использовать наши рабочие процессы использовать другие корпоративные инструменты несколькими способами. Например, организации могут пожелать использовать систему билетов на справочную службу в качестве отправной точки для новых запросов на предоставление виртуальных машин. Система билетов может сделать спокойный звонок для автоматизации, чтобы инициировать рабочий процесс.

=== API Entry Point

Мы можем позвонить в любой экземпляр автоматизации из API RESTFUL, выпустив A + POST + CALL в **/API/Automation_Requests ** и заложив хэш, кодированный параметром, кодируемый JSON, такой как следующее:

[source,ruby]
----
post_params = {
: version => '1.1',
: uri_parts => {
: namespace => 'acme/general',
: class => 'Методы',
: ancess => 'Helloworld'
  },
: requester => {
: auto_approve => true
  }
} .to_json
----

Мы можем вызвать API Restful из внешнего сценария Ruby, используя драгоценный камень `rest-client`. Как и прежде, мы запросим токен аутентификации, а затем используем его с последующими вызовами:

[source,ruby]
----
api_uri = 'https: // myserver/api'
url = uri.encode (api_uri + '/auth')
rest_return = restclient :: request.execute (
Метод :: get,
URL: URL,
: user => имя пользователя,
: пароль => пароль,
                          :headers    => {:accept => :json},
verify_ssl: false)
auth_token = json.parse (rest_return) ['auth_token']
----

Получив токен аутентификации, мы можем сделать звонок для запроса автоматизации с помощью нашей полезной нагрузки `post_params`:

[source,ruby]
----
url = uri.encode (api_uri + '/Automation_Requests')
rest_return = restclient :: request.execute (
Метод :: post,
URL: URL,
                          :headers    => {:accept        => :json, 
'x-auth-token' => auth_token},
: payload => post_params,
verify_ssl: false)
result = json.parse (rest_return)
----

Идентификатор запроса возвращается нам в результате первоначального вызова:

[source,ruby]
----
request_id = result ['results'] [0] ['id']
----

Мы называем опрос, чтобы проверить статус:

[source,ruby]
----
url = uri.encode (api_uri + "/Automation_Requests/#{request_id}")
rest_return = restclient :: request.execute (
Метод :: get,
URL: URL,
                          :headers    => {:accept        => :json, 
'x-auth-token' => auth_token},
verify_ssl: false)
result = json.parse (rest_return)
request_state = result ['request_state']
пока request_state == "Закончена"
ставит "проверку состояния завершения ..."
rest_return = restclient :: request.execute (
Метод :: get,
URL: URL,
                            :headers    => {:accept        => :json, 
'x-auth-token' => auth_token},
verify_ssl: false)
result = json.parse (rest_return)
request_state = result ['request_state']
Сон 3
конец
----

=== Returning Results to the Caller

Хэш для параметров запроса автоматизации включен в возврат из Call от + RestClient :: Request +, и мы можем использовать это в нашу пользу, используя + set_option + для добавления возвратных данных в форме паров ключей/значения в хэш параметров из нашего вызываемого метода автоматизации.

Например, из метода _called_ (Automate) мы можем включить следующее:

[source,ruby]
----
Automation_Request = $ evm.root ['Automation_task']. Automation_Request
Automation_Request.set_option (: return, json.generate ({: status => 'успех',
: return => some_data})))
----

Из метода _calling_ (внешний) мы можем затем проанализировать ключ + return + из хэша возвращаемых параметров и распечатать содержимое следующим образом:

[source,ruby]
----
result = json.parse (rest_return)
Положит «Результаты: #{result ['options'] ['return']. осмотреть}»
----

Используя эту технику, мы можем написать наши собственные псевдо-API-вызовы для CloudForms или Manageiq, чтобы справиться с всем, что стандартный API Restful не поддерживает. Мы реализуем «API», используя стандартный метод автоматизации, вызовываем его, используя вызов Restful Automate, и мы можем передать параметры и извлечь результат обратно из метода CALL.

=== Authentication and auto_approve

Когда мы делаем спокойный звонок, мы должны аутентифицировать подлинность, используя действительное имя пользователя и пароль (или последующий токен аутентификации). Этот пользователь должен быть администратором или эквивалентом, если мы хотим указать значение `: auto_approve`‘ true` в наших вызове (только администраторы могут автоматически одобрить запросы на автоматизацию).

Если мы попытаемся сделать спокойный звонок в качестве пользователя, не являющегося админ, запрос на автоматизацию будет заблокирован, ожидая одобрения (как и ожидалось). Если мы хотим отправить автоподобный запрос на автоматизацию в качестве пользователя, не являющегося админ, нам нужно будет написать наш собственный рабочий процесс утверждения (см.

=== Zone Implications

Когда мы отправляем запрос на автоматизацию через API, по умолчанию задача автоматизации находится в очереди на том же приборе, на котором работает веб -служба. Это будет выполнено для выполнения любого прибора с _automation Engine_ Set ** в той же зоне **. Если мы разделили наши приборы WebUI/веб -сервис в отдельной зоне, это не обязательно может быть нашим желаемым поведением.

Мы можем добавить параметр `: miq_zone` в запрос автоматизации, чтобы переопределить это:

[source,ruby]
----
: requester => {
: auto_approve => true
  },
: параметры => {
: miq_zone => 'Zone name'
  }
----

Поведение этого параметра выглядит следующим образом:

1. Если параметр не пройден, запрос должен использовать зону сервера, который получает запрос.
2. Если пройден, но пусто (например, параметры '=> "miq_zone =" `) зона должна быть установлена ​​на + nil +, и любое устройство может обработать запрос.
3. Переданный параметр имени зоны (например, параметры '=> "miq_zone = test" `) должен обработать работу в зоне" теста ".
4. Передача недопустимого имени зоны должно вызвать ошибку * неизвестной зоны <Zone_Name> * обратно к вызывающему абоненту.

=== run_via_api

Сопровождающий код https://github.com/pemcg/mastering-automation-in-coloudforms-4.2-and-manageiq-euwe/tree/master/calling_automation_using_the_restful_api/scriptsrhere], что используется argemate abhome asmentat передать имя сервера, учетные данные и параметры URI в экземпляр, который будет вызван. Его использование следующее:

----
Использование: run_via_api.rb [Параметры]
-s, сервер -сервер -сервер -сервер для подключения к
-u, -USERNAME USERNAME USERNAME, чтобы подключиться как
-p, пароль пароля -пассу
-Д, -домен домен
-n, -Намель пространство имен
-c, класс класса
-i, экземпляр
-P, -parameter <key, значение> параметр (key => pare pare) для экземпляра
-h, -help
----

Отредактируйте значения по умолчанию для сервера, имени пользователя и пароля, если это необходимо. Запустите сценарий как:

----
./Run_VIA_API.RB -S CloudForms01 -u Miqadmin -p Password -d acme -n General \
-c Методы -i addnic2vm -p vm_id, 1000000000195 -p nic_name, nic1 -p nic_network, vlan_712
----

=== Summary

В этой главе изучилось, как мы можем сделать Restful API -звонки в автоматизация, и, если необходимо, вернуть результаты обратно в абонента. Это очень мощная функция, которая позволяет нам использовать мощность автоматизации из внешних систем.

Например, мы можем реализовать двунаправленные рабочие процессы, в результате чего прибор CloudForms или Manageiq может выполнять отколечие звонки для интеграции с некоторым другим предприятием, возможно, для инициирования асинхронного действия, которое может занять некоторое время. Мы можем реализовать подпрограммы обратного вызова в качестве Rest-Hallable Automate Emptances, которые можно вызвать, чтобы сигнализировать о том, что внешняя обработка завершена.


==== Further Reading

https://github.com/manageiq/manageiq_docs/blob/master/api/reference/automation_requests.adocкти Ссылка - Запросы на автоматизацию]

https://github.com/manageiq/manageiq_docs/blob/master/api/examples/automation_request.adoctrigger один запрос на автоматизацию]

https://github.com/manageiq/manageiq_docs/blob/master/api/examples/automation_requests.adoctrigger Несколько запросов автоматизации]]
