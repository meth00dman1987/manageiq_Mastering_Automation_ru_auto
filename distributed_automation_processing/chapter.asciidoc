[[distributed-automation-processing]]
== Распределенная обработка автоматизации

Когда мы начинаем использовать Automate для расширения наших рабочих процессов в более широкое предприятие, мы можем обнаружить, что нам нужно добавить дополнительные облачные формы или устройства управления для распространения рабочей нагрузки в нашем регионе.

Automate был разработан, чтобы быть масштабируемым путем поддержки приборов распределенных рабочих, каждый из которых работает на роли * Automation Man Engine * и опрошены прибором базы данных VMDB для работы. В этой главе мы подробно рассмотрим, как распространяются операции автоматизации между приборами через центральную очередь. Это еще одна глава справочной информации, поэтому не стесняйтесь пропустить первое чтение или закладку для последующей ссылки.

=== Nondistributed Automation Operations

Не все операции автоматизации должны иметь распределенную возможность. Некоторые операции автоматизации взаимодействуют с пользователем через WebUI, и они требуют, чтобы экземпляр/метод был запускаться непосредственно в узле WebUI, в который пользователь регистрируется. Такие операции включают в себя:

* Запуск экземпляра автоматизации от симуляции
* Автоматизируя экземпляры, которые запускаются для заполнения динамических диалоговых элементов

Некоторые другие операции автоматизации должны быть выполнены синхронно и в определенном порядке, и они также выполняются на одном устройстве для гарантийного заказа выполнения. Примером этого является использование политики управления _synchronous_ тип действия ** вызовать пользовательскую автоматизацию **.

Роль * Automation Engine * не должна быть включена для выполнения этих неопределенных операций автоматизации.

=== Distributed Automation Operations

Большинство операций автоматизации выигрывают от масштабируемого и распределенного, и способного работать на любом приборе в нашей зоне с помощью набора ролей * Automation Engine. К ним относятся:

* Запуск экземпляра автоматизации с пользовательской кнопки
* Политика управления _Asynchronous_ тип действия * вызовой пользовательской автоматизации *
* Любые операции автоматизации, которые включают отдельные запросы и задачи

Распределенные задачи автоматизации передаются в механизм автоматизации с использованием стандартного механизма передачи сообщений, с помощью которого все работники общаются. Это через очередь, смоделированную в базе данных как таблица `miq_queue`. Общие работники, работающие на приборах с набором роли * Automation Fore *, отслеживайте эту очередь на наличие сообщений с полем `queue_name` of _generic_ и * роли * поля __automate__. Если такое сообщение будет найдено, оно отказано и обрабатывается.

=== Tracing Queueing/Dequeueing Operations

Мы можем осмотреть _evm.log_, чтобы увидеть деятельность по очереди сообщений между работником/отсрочкой, когда нажимается на пользовательскую кнопку, которая запускает задачу автоматизации (здесь строки были обернуты для ясности). Первое действие, которое мы видим, - это сообщение ResourceAction (кнопки выполняются как __resource actions__):

....
Miq (resourceaction#deliver_to_automate_from_dialog) \
В очереди <ResourceAction: 1000000000066> для <Custombutton: 1000000000001>
....

За этим сразу следует введение нового сообщения (#1000000158789) в очередь, содержащую данные задачи. Параметр _ROLE: [Automate] _ означает, что сообщение предназначено для механизма автоматизации.

....
Miq (miqqueue.put) идентификатор сообщения: [1000000158789], \
идентификатор: [], \
Зона: [по умолчанию], \
Роль: [Automate], \
Сервер: [], \
Ident: [generic], \
Идентификатор цели: [], \
Идентификатор экземпляра: [], \
Идентификатор задачи: [resource_action_100000000000066], \
Команда: [miqaeengine.deliver], \
Тайм -аут: [3600], \
Приоритет: [20], \
Состояние: [Готово], \
Доставка на: [], \
Данные: [], \
Args: [{: namespace => "System", \
: class_name => "process", \
: exance_name => "запрос", \
: Automate_message => Nil, \
:: attrs => {"class" => "methods", \
"экземпляр" => "ObjectWalker", \
"Пространство имен" => "материал", \
"запрос" => "call_instance", \
"Dialog_Walk_association_whitelist" => ""}, \
: object_type => "vmortemplate", \
: object_id => 1000000000024, \
: user_id => 1000000000001, \
: miq_group_id => 1000000000002, \
: tenant_id => 1000000000001}] \
....

Следующая строка журнала, в которой упоминается `идентификатор сообщения: [1000000158789]` Показывает это
Быть пониженной темой MiqPriorityWorker:

....
Miq (miqpriorityworker :: runner#get_message_via_drb) идентификатор сообщения: [1000000158789], \
Miqworker ID: [1000000000504], \
Зона: [по умолчанию], \
Роль: [Automate], \
Сервер: [], \
Ident: [generic], \
Идентификатор цели: [], \
Идентификатор экземпляра: [], \
Идентификатор задачи: [resource_action_100000000000066], \
Команда: [miqaeengine.deliver], \
Тайм -аут: [3600], приоритет: [20], \
Состояние: [dequeue], \
Доставка на: [], \
Данные: [], \
Args: [{: namespace => "System", \
: class_name => "process", \
: exance_name => "запрос", \
: Automate_message => Nil, \
:: attrs => {"class" => "methods", \
"экземпляр" => "ObjectWalker", \
"Пространство имен" => "материал", \
"запрос" => "call_instance", \
"Dialog_Walk_association_whitelist" => ""}, \
: object_type => "vmortemplate", \
: object_id => 1000000000024, \
: user_id => 1000000000001, \
: miq_group_id => 1000000000002, \
: tenant_id => 1000000000001}], \
Dequeed в: [3,494673879] секунд
....

Отсюда мы видим полезную нагрузку сообщения, доставленную в механизм автоматизации. Обратите внимание, что в файле log-файла действие задачи теперь префикс установлено ** Q-task_id **, за которым следует идентификатор задачи в сообщении:

....
Q-task_id ([[resource_action_1000000000066]) miq (miqqueue#доставка) \
Идентификатор сообщения: [1000000158789], доставка ...
Q-task_id ([[resource_action_1000000000066]) miq (miqaeengine.deliver) Доставка \
{"class" => "methods", \
"экземпляр" => "ObjectWalker", \
"Пространство имен" => "материал", \
"запрос" => "call_instance", \
"DILAOG_WALK_ASSOCIATION_WHITELIST" => ""} \
Для объекта [vmortemplate.1000000000024] с государством [] для автоматизации
....

Мы видим строку * q-task_id * много раз в _evm.log_. Это свидетельствует о том, что строка журнала была сгенерирована задачей, которая была создана в результате сообщения об отсчета, и что сообщение содержало действительный идентификатор задачи.

Наконец, целевой экземпляр запускается с помощью механизма автоматизации:

....
Q-task_id ([[resource_action_1000000000066]) \
<AutomationEngine> создание [/System/Process/запрос? \
Miqserver%3a%3amiq_server = 1000000000001 & \
Пользователь%3A%3Auser = 100000000000001 & \
Vmortemplate%3A%3AVM = 1000000000024 & \
класс = методы и \
dialog_walk_association_whitelist = & \
exants = objectwalker & \
namespace = works & \
object_name = запрос и \
запрос = call_instance & \
vmdb_object_type = vm]
....


=== Detailed Queue Analysis

В любое время таблица `miq_queue` в базе данных PostgreSQL содержит несколько сообщений:

----
vmdb_production =# select id, priority, method_name, wation, queue_name, class_name,
vmdb_production =# Zone, роль, msg_timeout от miq_queue;
id | Приоритет |  method_name |  Государство |      queue_name |
---------------+----------+-------------- +---------+-----------------------| ...
1000000160668 |      100 | perf_rollup | Готово | ems_metrics_processor | ...
1000000160710 |       20 | доставить | Готово | универсальный | ...
1000000160673 |      100 | perf_rollup | Готово | ems_metrics_processor | ...
1000000126295 |      100 | обновить | Готово | EMS_1000000000004 | ...
1000000160711 |       20 | доставить | Готово | универсальный | ...
1000000153572 |      100 | perf_rollup | Готово | ems_metrics_processor | ...
1000000154220 |      100 | perf_rollup | Готово | ems_metrics_processor | ...
...
----

Каждый тип работника запрашивает таблицу `miq_queue`, чтобы увидеть, есть ли какая -либо работа для ее соответствующей роли. Рабочие ищут сообщения с конкретным полем `queue_name`; Для сообщений, связанных с автоматизацией, это «универсальный».

Когда работа заявляет работник, статус сообщения изменяется с «готовой» на «Dequeue», и работник начинает обрабатывать сообщение.

==== Monitoring the Queue During an Automation Operation

Мы можем отслеживать таблицу `miq_queue` во время операции автоматизации, инициированной с спокойным вызовом. Следующий запрос SQL позволяет нам увидеть соответствующие сообщения:

....
vmdb_production =# select id, priority, method_name, catter, queue_name,
vmdb_production-# class_name, Zone, роль, msg_timeout от miq_queue, где
vmdb_production-# class_name like '%Automation%' или class_name как '%miqae%';
....

Поиск конкретных полей `class_name` таким образом позволяет нам также видеть сообщения Automate_event, которые не обрабатываются механистом автоматизации, но все еще имеют отношение к операции автоматизации.

Мы видим несколько сообщений, созданных и отправленных в течение короткого периода времени:

....
id | pri |     method_name | Государство | очередь |    class_name | ...
---------+-----+----------------------+-------+---------+-------------------+----
 ...1068 | 100 | call_automate_event  | ready | generic | AutomationRequest | ...
 ...1069 | 100 | call_automate_event  | ready | generic | AutomationRequest | ...
 ...1070 | 100 | create_request_tasks | ready | generic | AutomationRequest | ...
(3 ряда)
....

....

id | pri |     method_name |  Государство | очередь |    class_name ...
---------+-----+----------------------+---------+---------+------------------+...
 ...1071 |  20 | deliver              | ready   | generic | MiqAeEngine       ...
 ...1070 | 100 | create_request_tasks | ready   | generic | AutomationRequest ...
 ...1069 | 100 | call_automate_event  | dequeue | generic | AutomationRequest ...
(3 ряда)
....

....

id | pri |     method_name |  Государство | очередь |    class_name ...
---------+-----+----------------------+---------+---------+-------------------...
 ...1071 |  20 | deliver              | ready   | generic | MiqAeEngine       ...
 ...1072 |  20 | deliver              | ready   | generic | MiqAeEngine       ...
 ...1070 | 100 | create_request_tasks | dequeue | generic | AutomationRequest ...
(3 ряда)
....

....

id | pri | Метод_ | Государство | очередь |   class_name |  зона |   роль
---------+-----+---------+-------+---------+----------------+---------+-------...
 ...1071 |  20 | deliver | ready | generic | MiqAeEngine    | default | automa...
 ...1072 |  20 | deliver | ready | generic | MiqAeEngine    | default | automa...
 ...1073 | 100 | execute | ready | generic | AutomationTask | default | automa...
(3 ряда)
....

....

id | pri | Метод_ |  Государство | очередь |   class_name |  зона |   ro ...
---------+-----+---------+---------+---------+----------------+---------+-----...
 ...1071 |  20 | deliver | dequeue | generic | MiqAeEngine    | default | auto...
 ...1073 | 100 | execute | dequeue | generic | AutomationTask | default | auto...
(2 ряда)
....

....

id | pri | Метод_ |  Государство | очередь |   class_name |  зона |   ro ...
---------+-----+---------+---------+---------+----------------+---------+-----...
 ...1073 | 100 | execute | dequeue | generic | AutomationTask | default | auto...
(1 ряд)
....

....

id | pri | method_name | Государство | queue_name | class_name | зона | роль | MSG _...
----+-----+-------------+-------+------------+------------+------+------+-----...
(0 рядов)
....

Мы можем искать любой из этих идентификаторов сообщений в _evm.log_ и расширить их для проверки содержимого сообщения. Например, поиск идентификатора сообщения: 1000000161070 показывает:

....
Miq (miqqueue.put) идентификатор сообщения: [1000000161070], \
идентификатор: [], \
Зона: [по умолчанию], \
Роль: [Automate], \
Сервер: [], \
Ident: [generic], \
Идентификатор цели: [], \
Идентификатор экземпляра: [100000000000016], \
Идентификатор задачи: [Automation_Request_1000000000016], \
Команда: [AutomationRequest.create_Request_tasks], \
Тайм -аут: [3600], \
Приоритет: [100], \
Состояние: [Готово], \
Доставка на: [], \
Данные: [], \
Args: []
....

....
Miq (miqgenericworker :: runner#get_message_via_drb) идентификатор сообщения: [1000000161070], \
Miqworker ID: [1000000000503], \
Зона: [по умолчанию], \
Роль: [Automate], \
Сервер: [], \
Ident: [generic], \
Идентификатор цели: [], \
Идентификатор экземпляра: [100000000000016], \
Идентификатор задачи: [Automation_Request_1000000000016], \
Команда: [AutomationRequest.create_Request_tasks], \
Тайм -аут: [3600], \
Приоритет: [100], \
Состояние: [dequeue], \
Доставка на: [], \
Данные: [], \
Args: [], \
Dequed в: [5.622555094] секунд
....

....
Q-task_id ([Automation_Request_100000000000016]) Miq (miqqueue#Доставка) \
Идентификатор сообщения: [1000000161070], доставка ...
....

....
Q-task_id ([Automation_Request_100000000000016]) Miq (miqqueue#доставлен) \
Идентификатор сообщения: [1000000161070], состояние: [OK], доставлено в [1,866825831] секунд
....

Это соответствует действию очереди сообщений, сгенерированной методом `execute` в модуле Backend Rails __vmdb/App/Models/miq_request.rb__.

[source,ruby]
----
def Execute
task_check_on_execute

Dired_on = nil
Если get_option (: adage_type) == "Расписание"
deliver_on = get_option (: adage_time) .Utc rescue nil
конец

# self.create_request_tasks
Miqqueue.put (
: class_name => self.class.name,
: exance_id => id,
: method_name => "create_request_tasks",
      :zone        => options.fetch(:miq_zone, my_zone),
: role => my_role,
: task_id => "#{self.class.name.underscore} _#{id}",
: msg_timeout => 3600,
: deliver_on => deliver_on
    )
конец
----

Если мы ищем источники для + miqqueue.put +, мы увидим степень, в которой используется распределенный характер управления.

=== Troubleshooting

Поскольку (по проектированию) операции автоматизации в очереди могут быть выполнены и запускаться любым прибором в зоне с набором ролей * Automation Engination *, мы не можем предсказать, какое устройство будет запускать наш код. Это может сделать устранение неполадок `$ evm.log` -вывода более сложным, так как нам, возможно, потребуется поиск _automation.log_ в нескольких приборах, чтобы найти выход для журнала нашего метода. При прохождении сообщений об отслеживании enqueue `miqqueue.put` и соответствующих вызовов Dequeue` worker :: runner#get_message_via_drb`s может даже быть и на разных приборах.

Если задачи автоматизации не выполняются в распределенной установке Manageiq, часто стоит изучить содержимое таблицы `miq_queue`, чтобы увидеть, накапливаются ли автоматизация сообщений, и на какую зону предназначены сообщения для ( * Зона: [] * * Поле). Если сообщения не исчезают, как ожидалось, убедитесь, что роль * движения автомата * установлена ​​по крайней мере на одном устройстве в зоне.

Мы часто видим это при разделении приборов на различные специфические для роли зоны, такие как зона * webui * и * зона рабочей работы *. Вызовы автоматизации, выполненные с использованием API RESTFUL, на прибор в зоне * WebUI *, не будут работать, если роль * Automation Engine * не включена ни в одном из приборов * webui * Zone, или в Restful Call не указывается альтернативная зона для запуска.
